{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app.js","src/Drawer.js","src/MathHelper.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_Drawer","SmilesDrawer","Version","clean","smiles","replace","apply","options","selector","arguments","undefined","themeName","onError","smilesDrawer","_Drawer2","default","elements","document","querySelectorAll","element","parse","getAttribute","tree","draw","err","successCallback","errorCallback","Parser","Array","prototype","fill","Object","defineProperty","value","_value","this","TypeError","O","len","start","relativeStart","k","Math","max","min","end","relativeEnd","final","_MathHelper","Drawer","_classCallCheck","graph","ringIdCounter","ringConnectionIdCounter","canvasWrapper","totalOverlapScore","defaultOptions","width","height","bondThickness","bondLength","shortBondLength","bondSpacing","atomVisualization","isomeric","debug","terminalCarbons","explicitHydrogens","compactDrawing","fontSizeLarge","fontSizeSmall","themes","dark","C","N","F","CL","BR","I","P","S","B","SI","H","BACKGROUND","light","opts","extend","halfBondSpacing","bondLengthSq","halfFontSizeLarge","quarterFontSizeLarge","fifthFontSizeSmall","theme","that","extended","deep","toString","obj","prop","hasOwnProperty","data","target","infoOnly","CanvasWrapper","Graph","rings","ringConnections","originalRings","originalRingConnections","bridgedRing","initRings","annotateStereochemistry","vertices","isDrawn","position","restoreRingInformation","resolvePrimaryOverlaps","overlapScore","getOverlapScore","total","edges","edge","isEdgeRotatable","subTreeDepthA","getTreeDepth","sourceId","targetId","subTreeDepthB","b","getSubtreeOverlapScore","vertexScores","vertexA","vertexB","neighbours","getNeighbours","neighbour","angle","getRotateAwayFromAngle","_MathHelper2","toRad","rotateSubtree","id","newTotalOverlapScore","neighbourA","neighbourB","angleA","angleB","_newTotalOverlapScore","resolveSecondaryOverlaps","scores","scale","initPseudoElements","drawEdges","drawVertices","reset","edgeId","bridgedRings","isBridged","push","fusedRings","isFused","spiros","isSpiro","result","ring","members","hac","getRingbondCount","ringbonds","j","bondType","bond","openBonds","Map","vertex","ringbondId","has","sourceVertexId","targetVertexId","get","addEdge","Edge","targetVertex","addChild","addNeighbouringElement","delete","set","SSSR","getRings","ringVertices","concat","_toConsumableArray","ringId","addRing","Ring","ringConnection","RingConnection","size","addRingConnection","_ring","addAnchoredRing","backupRingInformation","_ring3","isPartOfBridgedRing","_ring2","getRing","involvedRings","getBridgedRingRings","createBridgedRing","removeRing","recurse","indexOf","isBridge","ArrayHelper","unique","containsRing","ringIds","ringMembers","Set","_ring4","isPartOfBridged","add","leftovers","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","_id","_vertex","intersection","return","insideRing","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_id2","_vertex2","onRing","_j","edgeRingCount","isBridgeNode","clone","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_id3","_vertex3","removeAll","removeRingConnectionsBetween","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_id4","connections","getRingConnections","getRingConnection","updateOther","commonRings","getCommonRings","maxSize","largestCommonRing","getSize","isBenzeneLike","radius","excludeVertexId","locals","positioned","distanceSq","minDist","minVertex","v","distSq","filter","item","firstRingId","secondRingId","ringConnectionId","vertexIdA","vertexIdB","toRemove","removeRingConnection","rc","overlapScores","Float32Array","dist","Vector2","subtract","lengthSq","weighted","sqrt","sortable","score","sort","sides","an","bn","anCount","bnCount","tn","merge","sideCount","sameSideAs","totalSideCount","totalPosition","ringSize","center","divide","smallest","Number","MAX_VALUE","drawn","traverseBF","getEdges","drawEdge","isRingAromatic","drawAromaticityRing","elementA","elementB","normals","getEdgeNormals","multiplyScalar","getRingbondType","isPartOfAromaticRing","inRing","areVerticesInSameRing","chooseSide","lcr","getLargestOrAromaticCommonRing","line","Line","shorten","drawLine","lineA","lineB","_lineA","_lineB","_line","_line2","_line3","_line4","_lineA2","_lineB2","isChiralCenterA","bracket","chirality","isChiralCenterB","chiral","drawWedge","drawDashedWedge","midpoint","drawDebugText","x","y","atom","charge","isotope","bondCount","getBondCount","hydrogens","Atom","maxBonds","dir","getTextDirection","isTerminal","hasAttachedPseudoElements","isCarbon","hcount","drawBall","drawExplicit","drawText","getAttachedPseudoElements","getNeighbourCount","forcePositioned","threePointangle","abs","PI","drawPoint","print","drawDebugPoint","startVertex","createNextBond","backupRings","getBridgedRings","restoreRings","previousVertex","orderedNeighbours","getOrderedNeighbours","startingAngle","polyCircumradius","centralAngle","startVertexId","kkLayout","slice","setRingCenter","eachMember","setPosition","cos","sin","getVertices","normalize","apothem","nextCenter","posA","posB","clockwise","createRing","_vertexA","_nextCenter","invert","_r","ringMember","ringMemberNeighbours","isConnectedToRing","getSubringCenter","_v2","previousPosition","vertexId","parentVertexId","traverseTree","rotateAround","anchoredRings","vertexOverlapScores","count","vec","rSq","overlaps","nonRingNeighbours","getNonRingNeighbours","common","overlap","getAngle","subTreeOverlapA","subTreeOverlapB","closest","getClosestVertex","closestPosition","vertexPreviousPosition","rotateAwayFrom","ringOrAngle","skipPositioning","vecs","avg","averageDirection","setPositionFromVector","_vecs","_neighbours","_neighbour","_avg","_neighbour2","rotate","globalAngle","dummy","nextRing","_nextRing","_nextCenter2","_r2","_neighbours2","remove","nextVertex","straightEdge1","getEdge","straightEdge2","proposedAngleA","proposedAngleB","proposedVectorA","proposedVectorB","centerOfMass","getCurrentCenterOfMass","distanceA","distanceB","_proposedAngleA","_proposedAngleB","_proposedVectorA","_proposedVectorB","_centerOfMass","_distanceA","_distanceB","subTreeDepthC","cis","trans","cisVertex","transVertex","d1","d2","d3","_r3","_proposedAngleA2","_proposedAngleB2","_proposedVectorA2","_proposedVectorB2","_centerOfMass2","_distanceA2","_distanceB2","_d","_d2","_d3","d4","w","z","All","radiusSq","source","v1","v2","units","getSpanningTreeNeighbours","childId","d","callback","maxDepth","ignoreFirst","depth","visited","nrneighbours","_this","nNeighbours","priorities","Uint8Array","priority","Uint16Array","visitStereochemistry","order","console","log","parityOfPermutation","atomicNumber","getAtomicNumber","_vertex4","neighbourIds","_neighbours3","heteroAtomCount","ctn","neighbouringElement","neighbourCount","previous","_neighbour3","_neighbour4","attachPseudoElement","_vertex5","_neighbourIds","_neighbours4","_neighbour5","getAttachedPseudoElementsCount","pseudoElements","MathHelper","decimals","round","arr","atan2","rad","degFactor","deg","radFactor","evenLengthCycleCount","cycleLength","traverseCycle","twoPI"],"mappings":"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","file":"smiles-drawer.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//@ts-check\r\nimport Drawer from './src/Drawer.js'\r\n\r\n/**\r\n * The SmilesDrawer namespace.\r\n * @typicalname SmilesDrawer\r\n */\r\nlet SmilesDrawer = {\r\n  Version: '1.0.0'\r\n};\r\n\r\n/**\r\n* Cleans a SMILES string (removes non-valid characters)\r\n*\r\n* @static\r\n* @param {String} smiles A SMILES string.\r\n* @returns {String} The clean SMILES string.\r\n*/\r\nSmilesDrawer.clean = function(smiles) {\r\n  return smiles.replace(/[^A-Za-z0-9@\\.\\+\\-\\?!\\(\\)\\[\\]\\{\\}/\\\\=#\\$:\\*]/g,'');\r\n}\r\n\r\n/**\r\n* Applies the smiles drawer draw function to each canvas element that has a smiles string in the data-smiles attribute.\r\n*\r\n* @static\r\n* @param {Object} options SmilesDrawer options.\r\n* @param {String} [selector='canvas[data-smiles]'] Selectors for the draw areas (canvas elements).\r\n* @param {String} [themeName='light'] The theme to apply.\r\n* @param {Function} [onError='null'] A callback function providing an error object.\r\n*/\r\nSmilesDrawer.apply = function(options, selector='canvas[data-smiles]', themeName='light', onError=null) {\r\n  let smilesDrawer = new Drawer(options);\r\n  let elements = document.querySelectorAll(selector);\r\n\r\n  for (var i = 0; i < elements.length; i++) {\r\n      let element = elements[i];\r\n\r\n      SmilesDrawer.parse(element.getAttribute('data-smiles'), function(tree) {\r\n          smilesDrawer.draw(tree, element, themeName, false);\r\n      }, function(err) {\r\n        if (onError) {\r\n          onError(err);\r\n        }\r\n      });\r\n  }\r\n}\r\n\r\n/**\r\n* Parses the entered smiles string.\r\n* \r\n* @static\r\n* @param {String} smiles A SMILES string.\r\n* @param {Function} successCallback A callback that is called on success with the parse tree.\r\n* @param {Function} errorCallback A callback that is called with the error object on error.\r\n*/\r\nSmilesDrawer.parse = function(smiles, successCallback, errorCallback) {\r\n  try {\r\n      if (successCallback) {\r\n          successCallback(SmilesDrawer.Parser.parse(smiles));\r\n      }\r\n  } catch (err) {\r\n      if (errorCallback) {\r\n          errorCallback(err);\r\n      }\r\n  }\r\n}\r\n\r\n\r\n// There be dragons (polyfills)\r\n\r\nif (!Array.prototype.fill) {\r\nObject.defineProperty(Array.prototype, 'fill', {\r\n  value: function(value) {\r\n\r\n    // Steps 1-2.\r\n    if (this == null) {\r\n      throw new TypeError('this is null or not defined');\r\n    }\r\n\r\n    var O = Object(this);\r\n\r\n    // Steps 3-5.\r\n    var len = O.length >>> 0;\r\n\r\n    // Steps 6-7.\r\n    var start = arguments[1];\r\n    var relativeStart = start >> 0;\r\n\r\n    // Step 8.\r\n    var k = relativeStart < 0 ?\r\n      Math.max(len + relativeStart, 0) :\r\n      Math.min(relativeStart, len);\r\n\r\n    // Steps 9-10.\r\n    var end = arguments[2];\r\n    var relativeEnd = end === undefined ?\r\n      len : end >> 0;\r\n\r\n    // Step 11.\r\n    var final = relativeEnd < 0 ?\r\n      Math.max(len + relativeEnd, 0) :\r\n      Math.min(relativeEnd, len);\r\n\r\n    // Step 12.\r\n    while (k < final) {\r\n      O[k] = value;\r\n      k++;\r\n    }\r\n\r\n    // Step 13.\r\n    return O;\r\n  }\r\n});\r\n}","//@ts-check\r\nimport MathHelper from './MathHelper'\r\n\r\n/** \r\n * The main class of the application representing the smiles drawer \r\n * \r\n * @property {SmilesDrawer.Graph} graph The graph associated with this SmilesDrawer.Drawer instance.\r\n * @property {Number} ringIdCounter An internal counter to keep track of ring ids.\r\n * @property {Number} ringConnectionIdCounter An internal counter to keep track of ring connection ids.\r\n * @property {SmilesDrawer.CanvasWrapper} canvasWrapper The SmilesDrawer.CanvasWrapper associated with this SmilesDrawer.Drawer instance.\r\n * @property {Number} totalOverlapScore The current internal total overlap score.\r\n * @property {Object} defaultOptions The default options.\r\n * @property {Object} opts The merged options.\r\n * @property {Object} theme The current theme.\r\n */\r\nexport default class Drawer {\r\n  /**\r\n   * The constructor for the class SmilesDrawer.\r\n   *\r\n   * @param {Object} options An object containing custom values for different options. It is merged with the default options.\r\n   */\r\n  constructor(options) {\r\n    this.graph = null;\r\n    this.ringIdCounter = 0;\r\n    this.ringConnectionIdCounter = 0;\r\n    this.canvasWrapper = null;\r\n    this.totalOverlapScore = 0;\r\n\r\n    this.defaultOptions = {\r\n      width: 500,\r\n      height: 500,\r\n      bondThickness: 0.6, // TODO: Add to doc\r\n      bondLength: 14.4,\r\n      shortBondLength: 0.85 * 14.4,\r\n      bondSpacing: 0.18 * 14.4,\r\n      atomVisualization: 'default',\r\n      isomeric: false,\r\n      debug: false,\r\n      terminalCarbons: false,\r\n      explicitHydrogens: true, // TODO: Add to doc\r\n      compactDrawing: true,\r\n      fontSizeLarge: 6,\r\n      fontSizeSmall: 4,\r\n      themes: {\r\n        dark: {\r\n          C: '#fff',\r\n          O: '#e74c3c',\r\n          N: '#3498db',\r\n          F: '#27ae60',\r\n          CL: '#16a085',\r\n          BR: '#d35400',\r\n          I: '#8e44ad',\r\n          P: '#d35400',\r\n          S: '#f1c40f',\r\n          B: '#e67e22',\r\n          SI: '#e67e22',\r\n          H: '#fff',\r\n          BACKGROUND: '#141414'\r\n        },\r\n        light: {\r\n          C: '#222',\r\n          O: '#e74c3c',\r\n          N: '#3498db',\r\n          F: '#27ae60',\r\n          CL: '#16a085',\r\n          BR: '#d35400',\r\n          I: '#8e44ad',\r\n          P: '#d35400',\r\n          S: '#f1c40f',\r\n          B: '#e67e22',\r\n          SI: '#e67e22',\r\n          H: '#222',\r\n          BACKGROUND: '#fff'\r\n        }\r\n      }\r\n    };\r\n\r\n    this.opts = this.extend(true, this.defaultOptions, options);\r\n    this.opts.halfBondSpacing = this.opts.bondSpacing / 2.0;\r\n    this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength;\r\n    this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2.0;\r\n    this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4.0;\r\n    this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5.0;\r\n\r\n    // Set the default theme.\r\n    this.theme = this.opts.themes.dark;\r\n  }\r\n\r\n  /**\r\n   * A helper method to extend the default options with user supplied ones.\r\n   */\r\n  extend() {\r\n    let that = this;\r\n    let extended = {};\r\n    let deep = false;\r\n    let i = 0;\r\n    let length = arguments.length;\r\n\r\n    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {\r\n      deep = arguments[0];\r\n      i++;\r\n    }\r\n\r\n    let merge = function (obj) {\r\n      for (var prop in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\r\n            extended[prop] = that.extend(true, extended[prop], obj[prop]);\r\n          } else {\r\n            extended[prop] = obj[prop];\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    for (; i < length; i++) {\r\n      let obj = arguments[i];\r\n      merge(obj);\r\n    }\r\n\r\n    return extended;\r\n  };\r\n\r\n\r\n  /**\r\n   * Draws the parsed smiles data to a canvas element.\r\n   *\r\n   * @param {Object} data The tree returned by the smiles parser.\r\n   * @param {String|HTMLElement} target The id of the HTML canvas element the structure is drawn to - or the element itself.\r\n   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.\r\n   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.\r\n   */\r\n  draw(data, target, themeName = 'light', infoOnly = false) {\r\n    this.data = data;\r\n    this.canvasWrapper = new SmilesDrawer.CanvasWrapper(target, this.opts.themes[themeName], this.opts);\r\n    this.infoOnly = infoOnly;\r\n\r\n    this.ringIdCounter = 0;\r\n    this.ringConnectionIdCounter = 0;\r\n\r\n    this.graph = new SmilesDrawer.Graph(data, this.opts.isomeric);\r\n    this.rings = [];\r\n    this.ringConnections = [];\r\n\r\n    this.originalRings = [];\r\n    this.originalRingConnections = [];\r\n\r\n    this.bridgedRing = false;\r\n\r\n    this.initRings();\r\n    this.annotateStereochemistry();\r\n\r\n    if (!this.opts.explicitHydrogens) {\r\n      for (var i = 0; i < this.graph.vertices.length; i++) {\r\n        if (this.graph.vertices[i].value.element === 'H') {\r\n          this.graph.vertices[i].value.isDrawn = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.opts.isomeric) {\r\n      this.annotateStereochemistry();\r\n    }\r\n\r\n    if (!this.infoOnly) {\r\n      this.position();\r\n\r\n      // Restore the ring information (removes bridged rings and replaces them with the original, multiple, rings)\r\n      this.restoreRingInformation();\r\n\r\n      // Atoms bonded to the same ring atom\r\n      this.resolvePrimaryOverlaps();\r\n\r\n      let overlapScore = this.getOverlapScore();\r\n\r\n      this.totalOverlapScore = this.getOverlapScore().total;\r\n\r\n      for (var i = 0; i < this.graph.edges.length; i++) {\r\n        let edge = this.graph.edges[i];\r\n\r\n        if (this.isEdgeRotatable(edge)) {\r\n          let subTreeDepthA = this.getTreeDepth(edge.sourceId, edge.targetId);\r\n          let subTreeDepthB = this.getTreeDepth(edge.targetId, edge.sourceId);\r\n\r\n          // Only rotate the shorter subtree\r\n          let a = edge.targetId;\r\n          let b = edge.sourceId;\r\n\r\n          if (subTreeDepthA > subTreeDepthB) {\r\n            a = edge.sourceId;\r\n            b = edge.targetId;\r\n          }\r\n\r\n          let subTreeOverlap = this.getSubtreeOverlapScore(b, a, overlapScore.vertexScores);\r\n\r\n          if (subTreeOverlap.value > 1.0) {\r\n            let vertexA = this.graph.vertices[a];\r\n            let vertexB = this.graph.vertices[b];\r\n            let neighbours = vertexB.getNeighbours(a);\r\n\r\n            if (neighbours.length === 1) {\r\n              let neighbour = this.graph.vertices[neighbours[0]];\r\n              let angle = neighbour.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));\r\n\r\n              this.rotateSubtree(neighbour.id, vertexB.id, angle, vertexB.position);\r\n\r\n              // If the new overlap is bigger, undo change\r\n              let newTotalOverlapScore = this.getOverlapScore().total;\r\n\r\n              if (newTotalOverlapScore > this.totalOverlapScore) {\r\n                this.rotateSubtree(neighbour.id, vertexB.id, -angle, vertexB.position);\r\n              } else {\r\n                this.totalOverlapScore = newTotalOverlapScore;\r\n              }\r\n            } else if (neighbours.length == 2) {\r\n              // Switch places / sides\r\n              // If vertex a is in a ring, do nothing\r\n              if (vertexB.value.rings.length + vertexA.value.rings.length > 0) {\r\n                continue;\r\n              }\r\n\r\n              let neighbourA = this.graph.vertices[neighbours[0]];\r\n              let neighbourB = this.graph.vertices[neighbours[1]];\r\n\r\n              let angleA = neighbourA.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));\r\n              let angleB = neighbourB.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));\r\n\r\n              this.rotateSubtree(neighbourA.id, vertexB.id, angleA, vertexB.position);\r\n              this.rotateSubtree(neighbourB.id, vertexB.id, angleB, vertexB.position);\r\n\r\n              let newTotalOverlapScore = this.getOverlapScore().total;\r\n\r\n              if (newTotalOverlapScore > this.totalOverlapScore) {\r\n                this.rotateSubtree(neighbourA.id, vertexB.id, -angleA, vertexB.position);\r\n                this.rotateSubtree(neighbourB.id, vertexB.id, -angleB, vertexB.position);\r\n              } else {\r\n                this.totalOverlapScore = newTotalOverlapScore;\r\n              }\r\n            }\r\n\r\n            overlapScore = this.getOverlapScore();\r\n          }\r\n        }\r\n      }\r\n\r\n      this.resolveSecondaryOverlaps(overlapScore.scores);\r\n\r\n      // Set the canvas to the appropriate size\r\n      this.canvasWrapper.scale(this.graph.vertices);\r\n\r\n      // Initialize pseudo elements or shortcuts\r\n      if (this.opts.compactDrawing && this.opts.atomVisualization === 'default') {\r\n        this.initPseudoElements();\r\n      }\r\n\r\n      // Do the actual drawing\r\n      this.drawEdges(this.opts.debug);\r\n      this.drawVertices(this.opts.debug);\r\n      this.canvasWrapper.reset();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the number of rings this edge is a part of.\r\n   *\r\n   * @param {Number} edgeId The id of an edge.\r\n   * @returns {Number} The number of rings the provided edge is part of.\r\n   */\r\n  edgeRingCount(edgeId) {\r\n    let edge = this.graph.edges[edgeId];\r\n    let a = this.graph.vertices[edge.sourceId];\r\n    let b = this.graph.vertices[edge.targetId];\r\n\r\n    return Math.min(a.value.rings.length, b.value.rings.length);\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing the bridged rings associated with this  molecule.\r\n   *\r\n   * @returns {SmilesDrawer.Ring[]} An array containing all bridged rings associated with this molecule.\r\n   */\r\n  getBridgedRings() {\r\n    let bridgedRings = [];\r\n\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      if (this.rings[i].isBridged) {\r\n        bridgedRings.push(this.rings[i]);\r\n      }\r\n    }\r\n\r\n    return bridgedRings;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing all fused rings associated with this molecule.\r\n   *\r\n   * @returns {SmilesDrawer.Ring[]} An array containing all fused rings associated with this molecule.\r\n   */\r\n  getFusedRings() {\r\n    let fusedRings = [];\r\n\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      if (this.rings[i].isFused) {\r\n        fusedRings.push(this.rings[i]);\r\n      }\r\n    }\r\n\r\n    return fusedRings;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing all spiros associated with this molecule.\r\n   *\r\n   * @returns {SmilesDrawer.Ring[]} An array containing all spiros associated with this molecule.\r\n   */\r\n  getSpiros() {\r\n    let spiros = [];\r\n\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      if (this.rings[i].isSpiro) {\r\n        spiros.push(this.rings[i]);\r\n      }\r\n    }\r\n\r\n    return spiros;\r\n  }\r\n\r\n  /**\r\n   * Returns a string containing a semicolon and new-line separated list of ring properties: Id; Members Count; Neighbours Count; IsSpiro; IsFused; IsBridged; Ring Count (subrings of bridged rings)\r\n   *\r\n   * @returns {String} A string as described in the method description.\r\n   */\r\n  printRingInfo() {\r\n    let result = '';\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      const ring = this.rings[i];\r\n\r\n      result += ring.id + ';';\r\n      result += ring.members.length + ';';\r\n      result += ring.neighbours.length + ';';\r\n      result += ring.isSpiro ? 'true;' : 'false;'\r\n      result += ring.isFused ? 'true;' : 'false;'\r\n      result += ring.isBridged ? 'true;' : 'false;'\r\n      result += ring.rings.length + ';';\r\n      result += '\\n';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the total overlap score of the current molecule.\r\n   *\r\n   * @returns {Number} The overlap score.\r\n   */\r\n  getTotalOverlapScore() {\r\n    return this.totalOverlapScore;\r\n  }\r\n\r\n  /**\r\n   * Returns the ring count of the current molecule.\r\n   *\r\n   * @returns {Number} The ring count.\r\n   */\r\n  getRingCount() {\r\n    return this.rings.length;\r\n  }\r\n\r\n  /**\r\n   * Checks whether or not the current molecule  a bridged ring.\r\n   *\r\n   * @returns {Boolean} A boolean indicating whether or not the current molecule  a bridged ring.\r\n   */\r\n  hasBridgedRing() {\r\n    return this.bridgedRing;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of heavy atoms (non-hydrogen) in the current molecule.\r\n   *\r\n   * @returns {Number} The heavy atom count.\r\n   */\r\n  getHeavyAtomCount() {\r\n    let hac = 0;\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      if (this.graph.vertices[i].value.element !== 'H') {\r\n        hac++;\r\n      }\r\n    }\r\n\r\n    return hac;\r\n  }\r\n\r\n  /**\r\n   * Returns the type of the ringbond (e.g. '=' for a double bond). The ringbond represents the break in a ring introduced when creating the MST. If the two vertices supplied as arguments are not part of a common ringbond, the method returns null.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertexA A vertex.\r\n   * @param {SmilesDrawer.Vertex} vertexB A vertex.\r\n   * @returns {String|null} Returns the ringbond type or null, if the two supplied vertices are not connected by a ringbond.\r\n   */\r\n  getRingbondType(vertexA, vertexB) {\r\n    // Checks whether the two vertices are the ones connecting the ring\r\n    // and what the bond type should be.\r\n    if (vertexA.value.getRingbondCount() < 1 || vertexB.value.getRingbondCount() < 1) {\r\n      return null;\r\n    }\r\n\r\n    for (var i = 0; i < vertexA.value.ringbonds.length; i++) {\r\n      for (var j = 0; j < vertexB.value.ringbonds.length; j++) {\r\n        // if(i != j) continue;\r\n        if (vertexA.value.ringbonds[i].id === vertexB.value.ringbonds[j].id) {\r\n          // If the bonds are equal, it doesn't matter which bond is returned.\r\n          // if they are not equal, return the one that is not the default (\"-\")\r\n          if (vertexA.value.ringbonds[i].bondType === '-') {\r\n            return vertexB.value.ringbonds[j].bond;\r\n          } else {\r\n            return vertexA.value.ringbonds[i].bond;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Initializes rings and ringbonds for the current molecule.\r\n   */\r\n  initRings() {\r\n    let openBonds = new Map();\r\n\r\n    // Close the open ring bonds (spanning tree -> graph)\r\n    for (var i = this.graph.vertices.length - 1; i >= 0; i--) {\r\n      let vertex = this.graph.vertices[i];\r\n\r\n      if (vertex.value.ringbonds.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      for (var j = 0; j < vertex.value.ringbonds.length; j++) {\r\n        let ringbondId = vertex.value.ringbonds[j].id;\r\n\r\n        // If the other ringbond id has not been discovered,\r\n        // add it to the open bonds map and continue.\r\n        // if the other ringbond id has already been discovered,\r\n        // create a bond between the two atoms.\r\n        if (!openBonds.has(ringbondId)) {\r\n          openBonds.set(ringbondId, vertex.id);\r\n        } else {\r\n          let sourceVertexId = vertex.id;\r\n          let targetVertexId = openBonds.get(ringbondId);\r\n          let edgeId = this.graph.addEdge(new SmilesDrawer.Edge(sourceVertexId, targetVertexId, 1));\r\n          let targetVertex = this.graph.vertices[targetVertexId];\r\n\r\n          vertex.addChild(targetVertexId);\r\n          vertex.value.addNeighbouringElement(targetVertex.value.element);\r\n          targetVertex.addChild(sourceVertexId);\r\n          targetVertex.value.addNeighbouringElement(vertex.value.element);\r\n          vertex.edges.push(edgeId);\r\n          targetVertex.edges.push(edgeId);\r\n\r\n          openBonds.delete(ringbondId);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get the rings in the graph (the SSSR)\r\n    let rings = SmilesDrawer.SSSR.getRings(this.graph);\r\n    \r\n    if (rings === null) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < rings.length; i++) {\r\n      let ringVertices = [...rings[i]];\r\n      let ringId = this.addRing(new SmilesDrawer.Ring(ringVertices));\r\n\r\n      // Add the ring to the atoms\r\n      for (var j = 0; j < ringVertices.length; j++) {\r\n        this.graph.vertices[ringVertices[j]].value.rings.push(ringId);\r\n      }\r\n    }\r\n\r\n    // Find connection between rings\r\n    // Check for common vertices and create ring connections. This is a bit\r\n    // ugly, but the ringcount is always fairly low (< 100)\r\n    for (var i = 0; i < this.rings.length - 1; i++) {\r\n      for (var j = i + 1; j < this.rings.length; j++) {\r\n        let a = this.rings[i];\r\n        let b = this.rings[j];\r\n        let ringConnection = new SmilesDrawer.RingConnection(a, b);\r\n\r\n        // If there are no vertices in the ring connection, then there\r\n        // is no ring connection\r\n        if (ringConnection.vertices.size > 0) {\r\n          this.addRingConnection(ringConnection);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add neighbours to the rings\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      let ring = this.rings[i];\r\n      ring.neighbours = SmilesDrawer.RingConnection.getNeighbours(this.ringConnections, ring.id);\r\n    }\r\n\r\n    // Anchor the ring to one of it's members, so that the ring center will always\r\n    // be tied to a single vertex when doing repositionings\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      let ring = this.rings[i];\r\n      this.graph.vertices[ring.members[0]].value.addAnchoredRing(ring.id);\r\n    }\r\n\r\n    // Backup the ring information to restore after placing the bridged ring.\r\n    // This is needed in order to identify aromatic rings and stuff like this in\r\n    // rings that are member of the superring.\r\n    this.backupRingInformation();\r\n\r\n\r\n    // Replace rings contained by a larger bridged ring with a bridged ring\r\n    while (this.rings.length > 0) {\r\n      let id = -1;\r\n      for (var i = 0; i < this.rings.length; i++) {\r\n        let ring = this.rings[i];\r\n\r\n        if (this.isPartOfBridgedRing(ring.id) && !ring.isBridged) {\r\n          id = ring.id;\r\n        }\r\n      }\r\n\r\n      if (id === -1) {\r\n        break;\r\n      }\r\n\r\n      let ring = this.getRing(id);\r\n\r\n      let involvedRings = this.getBridgedRingRings(ring.id);\r\n\r\n      this.bridgedRing = true;\r\n      this.createBridgedRing(involvedRings, ring.members[0]);\r\n\r\n      // Remove the rings\r\n      for (var i = 0; i < involvedRings.length; i++) {\r\n        this.removeRing(involvedRings[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all rings connected by bridged bonds starting from the ring with the supplied ring id.\r\n   *\r\n   * @param {Number} ringId A ring id.\r\n   * @returns {Number[]} An array containing all ring ids of rings part of a bridged ring system.\r\n   */\r\n  getBridgedRingRings(ringId) {\r\n    let involvedRings = [];\r\n    let that = this;\r\n\r\n    let recurse = function (r) {\r\n      let ring = that.getRing(r);\r\n\r\n      involvedRings.push(r);\r\n\r\n      for (var i = 0; i < ring.neighbours.length; i++) {\r\n        let n = ring.neighbours[i];\r\n\r\n        if (involvedRings.indexOf(n) === -1 &&\r\n          n !== r &&\r\n          SmilesDrawer.RingConnection.isBridge(that.ringConnections, that.graph.vertices, r, n)) {\r\n          recurse(n);\r\n        }\r\n      }\r\n    };\r\n\r\n    recurse(ringId);\r\n\r\n    return SmilesDrawer.ArrayHelper.unique(involvedRings);\r\n  }\r\n\r\n  /**\r\n   * Checks whether or not a ring is part of a bridged ring.\r\n   *\r\n   * @param {Number} ringId A ring id.\r\n   * @returns {Boolean} A boolean indicating whether or not the supplied ring (by id) is part of a bridged ring system.\r\n   */\r\n  isPartOfBridgedRing(ringId) {\r\n    for (var i = 0; i < this.ringConnections.length; i++) {\r\n      if (this.ringConnections[i].containsRing(ringId) &&\r\n        this.ringConnections[i].isBridge(this.graph.vertices)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Creates a bridged ring.\r\n   *\r\n   * @param {Number[]} ringIds An array of ids of rings involved in the bridged ring.\r\n   * @param {Number} sourceVertexId The vertex id to start the bridged ring discovery from.\r\n   * @returns {SmilesDrawer.Ring} The bridged ring.\r\n   */\r\n  createBridgedRing(ringIds, sourceVertexId) {\r\n    let ringMembers = new Set();\r\n    let vertices = new Set();\r\n    let neighbours = new Set();\r\n\r\n    for (var i = 0; i < ringIds.length; i++) {\r\n      let ring = this.getRing(ringIds[i]);\r\n      ring.isPartOfBridged = true;\r\n\r\n      for (var j = 0; j < ring.members.length; j++) {\r\n        vertices.add(ring.members[j]);\r\n      }\r\n\r\n      for (var j = 0; j < ring.neighbours.length; j++) {\r\n        let id  = ring.neighbours[j];\r\n\r\n        if (ringIds.indexOf(id) === -1) {\r\n          neighbours.add(ring.neighbours[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // A vertex is part of the bridged ring if it only belongs to\r\n    // one of the rings (or to another ring\r\n    // which is not part of the bridged ring).\r\n    let leftovers = new Set();\r\n\r\n    for (let id of vertices) {\r\n      let vertex = this.graph.vertices[id];\r\n      let intersection = SmilesDrawer.ArrayHelper.intersection(ringIds, vertex.value.rings);\r\n\r\n      if (vertex.value.rings.length === 1 || intersection.length === 1) {\r\n        ringMembers.add(vertex.id);\r\n      } else {\r\n        leftovers.add(vertex.id);\r\n      }\r\n    }\r\n\r\n    // Vertices can also be part of multiple rings and lay on the bridged ring,\r\n    // however, they have to have at least two neighbours that are not part of\r\n    // two rings\r\n    let tmp = [];\r\n    let insideRing = [];\r\n\r\n    for (let id of leftovers) {\r\n      let vertex = this.graph.vertices[id];\r\n      let onRing = false;\r\n\r\n      for (let j = 0; j < vertex.edges.length; j++) {\r\n        if (this.edgeRingCount(vertex.edges[j]) === 1) {\r\n          onRing = true;\r\n        }\r\n      }\r\n\r\n      if (onRing) {\r\n        vertex.value.isBridgeNode = true;\r\n        ringMembers.add(vertex.id);\r\n      } else {\r\n        vertex.value.isBridge = true;\r\n        ringMembers.add(vertex.id);\r\n      }\r\n    }\r\n\r\n    // Create the ring\r\n    let ring = new SmilesDrawer.Ring([...ringMembers]);\r\n\r\n    ring.isBridged = true;\r\n    ring.neighbours = [...neighbours];\r\n\r\n    for (var i = 0; i < ringIds.length; i++) {\r\n      ring.rings.push(this.getRing(ringIds[i]).clone());\r\n    }\r\n\r\n    this.addRing(ring);\r\n\r\n    for (var i = 0; i < ring.members.length; i++) {\r\n      this.graph.vertices[ring.members[i]].value.bridgedRing = ring.id;\r\n    }\r\n\r\n    // Atoms inside the ring are no longer part of a ring but are now\r\n    // associated with the bridged ring\r\n    for (var i = 0; i < insideRing.length; i++) {\r\n      let vertex = this.graph.vertices[insideRing[i]];\r\n      vertex.value.rings = Array();\r\n    }\r\n\r\n    // Remove former rings from members of the bridged ring and add the bridged ring\r\n    for (let id of ringMembers) {\r\n      let vertex = this.graph.vertices[id];\r\n      vertex.value.rings = SmilesDrawer.ArrayHelper.removeAll(vertex.value.rings, ringIds);\r\n      vertex.value.rings.push(ring.id);\r\n    }\r\n\r\n    // Remove all the ring connections no longer used\r\n    for (var i = 0; i < ringIds.length; i++) {\r\n      for (var j = i + 1; j < ringIds.length; j++) {\r\n        this.removeRingConnectionsBetween(ringIds[i], ringIds[j]);\r\n      }\r\n    }\r\n\r\n    // Update the ring connections and add this ring to the neighbours neighbours\r\n    for (let id of neighbours) {\r\n      let connections = this.getRingConnections(id, ringIds);\r\n\r\n      for (var j = 0; j < connections.length; j++) {\r\n        this.getRingConnection(connections[j]).updateOther(ring.id, id);\r\n      }\r\n\r\n      this.getRing(id).neighbours.push(ring.id);\r\n    }\r\n\r\n    return ring;\r\n  }\r\n\r\n  /**\r\n   * Checks whether or not two vertices are in the same ring.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertexA A vertex.\r\n   * @param {SmilesDrawer.Vertex} vertexB A vertex.\r\n   * @returns {Boolean} A boolean indicating whether or not the two vertices are in the same ring.\r\n   */\r\n  areVerticesInSameRing(vertexA, vertexB) {\r\n    // This is a little bit lighter (without the array and push) than\r\n    // getCommonRings().length > 0\r\n    for (var i = 0; i < vertexA.value.rings.length; i++) {\r\n      for (var j = 0; j < vertexB.value.rings.length; j++) {\r\n        if (vertexA.value.rings[i] === vertexB.value.rings[j]) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of ring ids shared by both vertices.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertexA A vertex.\r\n   * @param {SmilesDrawer.Vertex} vertexB A vertex.\r\n   * @returns {Number[]} An array of ids of rings shared by the two vertices.\r\n   */\r\n  getCommonRings(vertexA, vertexB) {\r\n    let commonRings = [];\r\n\r\n    for (var i = 0; i < vertexA.value.rings.length; i++) {\r\n      for (var j = 0; j < vertexB.value.rings.length; j++) {\r\n        if (vertexA.value.rings[i] == vertexB.value.rings[j]) {\r\n          commonRings.push(vertexA.value.rings[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return commonRings;\r\n  }\r\n\r\n  /**\r\n   * Returns the aromatic or largest ring shared by the two vertices.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertexA A vertex.\r\n   * @param {SmilesDrawer.Vertex} vertexB A vertex.\r\n   * @returns {SmilesDrawer.Ring|null} If an aromatic common ring exists, that ring, else the largest (non-aromatic) ring, else null.\r\n   */\r\n  getLargestOrAromaticCommonRing(vertexA, vertexB) {\r\n    let commonRings = this.getCommonRings(vertexA, vertexB);\r\n    let maxSize = 0;\r\n    let largestCommonRing = null;\r\n\r\n    for (var i = 0; i < commonRings.length; i++) {\r\n      let ring = this.getRing(commonRings[i]);\r\n      let size = ring.getSize();\r\n\r\n      if (ring.isBenzeneLike(this.graph.vertices)) {\r\n        return ring;\r\n      } else if (size > maxSize) {\r\n        maxSize = size;\r\n        largestCommonRing = ring;\r\n      }\r\n    }\r\n\r\n    return largestCommonRing;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of vertices positioned at a specified location.\r\n   *\r\n   * @param {SmilesDrawer.Vector2} position The position to search for vertices.\r\n   * @param {Number} radius The radius within to search.\r\n   * @param {Number} excludeVertexId A vertex id to be excluded from the search results.\r\n   * @returns {Number[]} An array containing vertex ids in a given location.\r\n   */\r\n  getVerticesAt(position, radius, excludeVertexId) {\r\n    let locals = [];\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let vertex = this.graph.vertices[i];\r\n\r\n      if (vertex.id === excludeVertexId || !vertex.positioned) {\r\n        continue;\r\n      }\r\n\r\n      let distance = position.distanceSq(vertex.position);\r\n\r\n      if (distance <= radius * radius) {\r\n        locals.push(vertex.id);\r\n      }\r\n    }\r\n\r\n    return locals;\r\n  }\r\n\r\n  /**\r\n   * Returns the closest vertex (connected as well as unconnected).\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertex The vertex of which to find the closest other vertex.\r\n   * @returns {SmilesDrawer.Vertex} The closest vertex.\r\n   */\r\n  getClosestVertex(vertex) {\r\n    let minDist = 99999;\r\n    let minVertex = null;\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let v = this.graph.vertices[i];\r\n\r\n      if (v.id === vertex.id) {\r\n        continue;\r\n      }\r\n\r\n      let distSq = vertex.position.distanceSq(v.position);\r\n\r\n      if (distSq < minDist) {\r\n        minDist = distSq;\r\n        minVertex = v;\r\n      }\r\n    }\r\n\r\n    return minVertex;\r\n  }\r\n\r\n  /**\r\n   * Add a ring to this representation of a molecule.\r\n   *\r\n   * @param {SmilesDrawer.Ring} ring A new ring.\r\n   * @returns {Number} The ring id of the new ring.\r\n   */\r\n  addRing(ring) {\r\n    ring.id = this.ringIdCounter++;\r\n    this.rings.push(ring);\r\n\r\n    return ring.id;\r\n  }\r\n\r\n  /**\r\n   * Removes a ring from the array of rings associated with the current molecule.\r\n   *\r\n   * @param {Number} ringId A ring id.\r\n   */\r\n  removeRing(ringId) {\r\n    this.rings = this.rings.filter(function (item) {\r\n      return item.id !== ringId;\r\n    });\r\n\r\n    // Also remove ring connections involving this ring\r\n    this.ringConnections = this.ringConnections.filter(function (item) {\r\n      return item.firstRingId !== ringId && item.secondRingId !== ringId;\r\n    });\r\n\r\n    // Remove the ring as neighbour of other rings\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      let r = this.rings[i];\r\n      r.neighbours = r.neighbours.filter(function (item) {\r\n        return item !== ringId;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets a ring object from the array of rings associated with the current molecule by its id. The ring id is not equal to the index, since rings can be added and removed when processing bridged rings.\r\n   *\r\n   * @param {Number} ringId A ring id.\r\n   * @returns {SmilesDrawer.Ring} A ring associated with the current molecule.\r\n   */\r\n  getRing(ringId) {\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      if (this.rings[i].id == ringId) {\r\n        return this.rings[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a ring connection to this representation of a molecule.\r\n   *\r\n   * @param {SmilesDrawer.RingConnection} ringConnection A new ringConnection.\r\n   * @returns {Number} The ring connection id of the new ring connection.\r\n   */\r\n  addRingConnection(ringConnection) {\r\n    ringConnection.id = this.ringConnectionIdCounter++;\r\n    this.ringConnections.push(ringConnection);\r\n\r\n    return ringConnection.id;\r\n  }\r\n\r\n  /**\r\n   * Removes a ring connection from the array of rings connections associated with the current molecule.\r\n   *\r\n   * @param {Number} ringConnectionId A ring connection id.\r\n   */\r\n  removeRingConnection(ringConnectionId) {\r\n    this.ringConnections = this.ringConnections.filter(function (item) {\r\n      return item.id !== ringConnectionId;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes all ring connections between two vertices.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   */\r\n  removeRingConnectionsBetween(vertexIdA, vertexIdB) {\r\n    let toRemove = [];\r\n    for (var i = 0; i < this.ringConnections.length; i++) {\r\n      let ringConnection = this.ringConnections[i];\r\n\r\n      if (ringConnection.firstRingId === vertexIdA && ringConnection.secondRingId === vertexIdB ||\r\n        ringConnection.firstRingId === vertexIdB && ringConnection.secondRingId === vertexIdA) {\r\n        toRemove.push(ringConnection.id);\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < toRemove.length; i++) {\r\n      this.removeRingConnection(toRemove[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a ring connection with a given id.\r\n   * \r\n   * @param {Number} id \r\n   * @returns {SmilesDrawer.RingConnection} The ring connection with the specified id.\r\n   */\r\n  getRingConnection(id) {\r\n    for (var i = 0; i < this.ringConnections.length; i++) {\r\n      if (this.ringConnections[i].id == id) {\r\n        return this.ringConnections[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the ring connections between a ring and a set of rings.\r\n   *\r\n   * @param {Number} ringId A ring id.\r\n   * @param {Number[]} ringIds An array of ring ids.\r\n   * @returns {Number[]} An array of ring connection ids.\r\n   */\r\n  getRingConnections(ringId, ringIds) {\r\n    let ringConnections = [];\r\n\r\n    for (var i = 0; i < this.ringConnections.length; i++) {\r\n      let rc = this.ringConnections[i];\r\n\r\n      for (var j = 0; j < ringIds.length; j++) {\r\n        let id = ringIds[j];\r\n\r\n        if (rc.firstRingId === ringId && rc.secondRingId === id ||\r\n          rc.firstRingId === id && rc.secondRingId === ringId) {\r\n          ringConnections.push(rc.id);\r\n        }\r\n      }\r\n    }\r\n\r\n    return ringConnections;\r\n  }\r\n\r\n  /**\r\n   * Returns the overlap score of the current molecule based on its positioned vertices. The higher the score, the more overlaps occur in the structure drawing.\r\n   *\r\n   * @returns {Object} Returns the total overlap score and the overlap score of each vertex sorted by score (higher to lower). Example: { total: 99, scores: [ { id: 0, score: 22 }, ... ]  }\r\n   */\r\n  getOverlapScore() {\r\n    let total = 0.0;\r\n    let overlapScores = new Float32Array(this.graph.vertices.length);\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      overlapScores[i] = 0;\r\n    }\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      var j = this.graph.vertices.length;\r\n      while (--j > i) {\r\n        let a = this.graph.vertices[i];\r\n        let b = this.graph.vertices[j];\r\n\r\n        if (!a.value.isDrawn || !b.value.isDrawn) {\r\n          continue;\r\n        }\r\n\r\n        let dist = SmilesDrawer.Vector2.subtract(a.position, b.position).lengthSq();\r\n\r\n        if (dist < this.opts.bondLengthSq) {\r\n          let weighted = (this.opts.bondLength - Math.sqrt(dist)) / this.opts.bondLength;\r\n          total += weighted;\r\n          overlapScores[i] += weighted;\r\n          overlapScores[j] += weighted;\r\n        }\r\n      }\r\n    }\r\n    \r\n    let sortable = [];\r\n    \r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      sortable.push({\r\n        id: i,\r\n        score: overlapScores[i]\r\n      });\r\n    }\r\n\r\n    sortable.sort(function (a, b) {\r\n      return b.score - a.score;\r\n    });\r\n    \r\n    return {\r\n      total: total,\r\n      scores: sortable,\r\n      vertexScores: overlapScores\r\n    };\r\n  }\r\n\r\n  /**\r\n   * When drawing a double bond, choose the side to place the double bond. E.g. a double bond should always been drawn inside a ring.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertexA A vertex.\r\n   * @param {SmilesDrawer.Vertex} vertexB A vertex.\r\n   * @param {SmilesDrawer.Vector2[]} sides An array containing the two normals of the line spanned by the two provided vertices.\r\n   * @returns {Object} Returns an object containing the following information: {\r\n          totalSideCount: Counts the sides of each vertex in the molecule, is an array [ a, b ],\r\n          totalPosition: Same as position, but based on entire molecule,\r\n          sideCount: Counts the sides of each neighbour, is an array [ a, b ],\r\n          position: which side to position the second bond, is 0 or 1, represents the index in the normal array. This is based on only the neighbours\r\n          anCount: the number of neighbours of vertexA,\r\n          bnCount: the number of neighbours of vertexB\r\n      }\r\n   */\r\n  chooseSide(vertexA, vertexB, sides) {\r\n    // Check which side has more vertices\r\n    // Get all the vertices connected to the both ends\r\n    let an = vertexA.getNeighbours(vertexB.id);\r\n    let bn = vertexB.getNeighbours(vertexA.id);\r\n    let anCount = an.length;\r\n    let bnCount = bn.length;\r\n\r\n    // All vertices connected to the edge vertexA to vertexB\r\n    let tn = SmilesDrawer.ArrayHelper.merge(an, bn);\r\n\r\n    // Only considering the connected vertices\r\n    let sideCount = [0, 0];\r\n\r\n    for (var i = 0; i < tn.length; i++) {\r\n      let v = this.graph.vertices[tn[i]].position;\r\n\r\n      if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {\r\n        sideCount[0]++;\r\n      } else {\r\n        sideCount[1]++;\r\n      }\r\n    }\r\n\r\n    // Considering all vertices in the graph, this is to resolve ties\r\n    // from the above side counts\r\n    let totalSideCount = [0, 0];\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let v = this.graph.vertices[i].position;\r\n\r\n      if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {\r\n        totalSideCount[0]++;\r\n      } else {\r\n        totalSideCount[1]++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalSideCount: totalSideCount,\r\n      totalPosition: totalSideCount[0] > totalSideCount[1] ? 0 : 1,\r\n      sideCount: sideCount,\r\n      position: sideCount[0] > sideCount[1] ? 0 : 1,\r\n      anCount: anCount,\r\n      bnCount: bnCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sets the center for a ring.\r\n   *\r\n   * @param {SmilesDrawer.Ring} ring A ring.\r\n   */\r\n  setRingCenter(ring) {\r\n    let ringSize = ring.getSize();\r\n    let total = new SmilesDrawer.Vector2();\r\n\r\n    for (var i = 0; i < ringSize; i++) {\r\n      total.add(this.graph.vertices[ring.members[i]].position);\r\n    }\r\n\r\n    ring.center = total.divide(ringSize);\r\n  }\r\n\r\n  /**\r\n   * Gets the center of a ring contained within a bridged ring and containing a given vertex.\r\n   *\r\n   * @param {SmilesDrawer.Ring} ring A bridged ring.\r\n   * @param {SmilesDrawer.Vertex} vertex A vertex.\r\n   * @returns {SmilesDrawer.Vector2} The center of the subring that containing the vertex.\r\n   */\r\n  getSubringCenter(ring, vertex) {\r\n    let rings = vertex.value.originalRings;\r\n    let center = ring.center;\r\n    let smallest = Number.MAX_VALUE;\r\n\r\n    // Always get the smallest ring.\r\n    var i = rings.length;\r\n    for (var i = 0; i < rings.length; i++) {\r\n      for (var j = 0; j < ring.rings.length; j++) {\r\n        if (rings[i] === ring.rings[j].id) {\r\n          if (ring.rings[j].getSize() < smallest) {\r\n            center = ring.rings[j].center;\r\n            smallest = ring.rings[j].getSize();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return center;\r\n  }\r\n\r\n  /**\r\n   * Draw the actual edges as bonds to the canvas.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdges(debug) {\r\n    let that = this;\r\n    let drawn = Array(this.graph.edges.length);\r\n    drawn.fill(false);\r\n\r\n    this.graph.traverseBF(0, function (vertex) {\r\n      let edges = that.graph.getEdges(vertex.id);\r\n      for (var i = 0; i < edges.length; i++) {\r\n        let edgeId = edges[i];\r\n        if (!drawn[edgeId]) {\r\n          drawn[edgeId] = true;\r\n          that.drawEdge(edgeId, debug);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Draw ring for implicitly defined aromatic rings\r\n    if (!this.bridgedRing) {\r\n      for (var i = 0; i < this.rings.length; i++) {\r\n        let ring = this.rings[i];\r\n\r\n        if (this.isRingAromatic(ring)) {\r\n          this.canvasWrapper.drawAromaticityRing(ring);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw the an edge as a bonds to the canvas.\r\n   *\r\n   * @param {Number} edgeId An edge id.\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdge(edgeId, debug) {\r\n    let that = this;\r\n    let edge = this.graph.edges[edgeId];\r\n    let vertexA = this.graph.vertices[edge.sourceId];\r\n    let vertexB = this.graph.vertices[edge.targetId];\r\n    let elementA = vertexA.value.element;\r\n    let elementB = vertexB.value.element;\r\n\r\n    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && this.opts.atomVisualization === 'default') {\r\n      return;\r\n    }\r\n\r\n    let a = vertexA.position;\r\n    let b = vertexB.position;\r\n    let normals = this.getEdgeNormals(edge);\r\n\r\n    // Create a point on each side of the line\r\n    let sides = SmilesDrawer.ArrayHelper.clone(normals);\r\n\r\n    sides[0].multiplyScalar(10).add(a);\r\n    sides[1].multiplyScalar(10).add(a);\r\n\r\n    if (edge.bondType === '=' || this.getRingbondType(vertexA, vertexB) === '=' ||\r\n      (edge.isPartOfAromaticRing && this.bridgedRing)) {\r\n      // Always draw double bonds inside the ring\r\n      let inRing = this.areVerticesInSameRing(vertexA, vertexB);\r\n      let s = this.chooseSide(vertexA, vertexB, sides);\r\n\r\n      if (inRing) {\r\n        // Always draw double bonds inside a ring\r\n        // if the bond is shared by two rings, it is drawn in the larger\r\n        // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this\r\n        let lcr = this.getLargestOrAromaticCommonRing(vertexA, vertexB);\r\n        let center = lcr.center;\r\n\r\n        normals[0].multiplyScalar(that.opts.bondSpacing);\r\n        normals[1].multiplyScalar(that.opts.bondSpacing);\r\n\r\n        // Choose the normal that is on the same side as the center\r\n        let line = null;\r\n\r\n        if (center.sameSideAs(vertexA.position, vertexB.position, SmilesDrawer.Vector2.add(a, normals[0]))) {\r\n          line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n        } else {\r\n          line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n        }\r\n\r\n        line.shorten(this.opts.bondLength - this.opts.shortBondLength);\r\n        \r\n        // The shortened edge\r\n        if (edge.isPartOfAromaticRing) {\r\n          this.canvasWrapper.drawLine(line, true);\r\n        } else {\r\n          this.canvasWrapper.drawLine(line);\r\n        }\r\n        \r\n        // The normal edge\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n      } else if (edge.center) {\r\n        normals[0].multiplyScalar(that.opts.halfBondSpacing);\r\n        normals[1].multiplyScalar(that.opts.halfBondSpacing);\r\n\r\n        let lineA = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n        let lineB = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        this.canvasWrapper.drawLine(lineA);\r\n        this.canvasWrapper.drawLine(lineB);\r\n      } else if (s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1) {\r\n        // Both lines are the same length here\r\n        // Add the spacing to the edges (which are of unit length)\r\n        normals[0].multiplyScalar(that.opts.halfBondSpacing);\r\n        normals[1].multiplyScalar(that.opts.halfBondSpacing);\r\n\r\n        let lineA = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n        let lineB = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        this.canvasWrapper.drawLine(lineA);\r\n        this.canvasWrapper.drawLine(lineB);\r\n      } else if (s.sideCount[0] > s.sideCount[1]) {\r\n        normals[0].multiplyScalar(that.opts.bondSpacing);\r\n        normals[1].multiplyScalar(that.opts.bondSpacing);\r\n\r\n        let line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n\r\n        line.shorten(this.opts.bondLength - this.opts.shortBondLength);\r\n        this.canvasWrapper.drawLine(line);\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n      } else if (s.sideCount[0] < s.sideCount[1]) {\r\n        normals[0].multiplyScalar(that.opts.bondSpacing);\r\n        normals[1].multiplyScalar(that.opts.bondSpacing);\r\n\r\n        let line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        line.shorten(this.opts.bondLength - this.opts.shortBondLength);\r\n        this.canvasWrapper.drawLine(line);\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n      } else if (s.totalSideCount[0] > s.totalSideCount[1]) {\r\n        normals[0].multiplyScalar(that.opts.bondSpacing);\r\n        normals[1].multiplyScalar(that.opts.bondSpacing);\r\n\r\n        let line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n\r\n        line.shorten(this.opts.bondLength - this.opts.shortBondLength);\r\n        this.canvasWrapper.drawLine(line);\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n      } else if (s.totalSideCount[0] <= s.totalSideCount[1]) {\r\n        normals[0].multiplyScalar(that.opts.bondSpacing);\r\n        normals[1].multiplyScalar(that.opts.bondSpacing);\r\n\r\n        let line = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        line.shorten(this.opts.bondLength - this.opts.shortBondLength);\r\n        this.canvasWrapper.drawLine(line);\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n      } else {\r\n\r\n      }\r\n    } else if (edge.bondType === '#') {\r\n      normals[0].multiplyScalar(that.opts.bondSpacing / 1.5);\r\n      normals[1].multiplyScalar(that.opts.bondSpacing / 1.5);\r\n\r\n      let lineA = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[0]), SmilesDrawer.Vector2.add(b, normals[0]), elementA, elementB);\r\n      let lineB = new SmilesDrawer.Line(SmilesDrawer.Vector2.add(a, normals[1]), SmilesDrawer.Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n      this.canvasWrapper.drawLine(lineA);\r\n      this.canvasWrapper.drawLine(lineB);\r\n\r\n      this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB));\r\n    } else if (edge.bondType === '.') {\r\n      // TODO: Something... maybe... version 2?\r\n    } else {\r\n      let isChiralCenterA = vertexA.value.bracket && vertexA.value.bracket.chirality;\r\n      let isChiralCenterB = vertexB.value.bracket && vertexB.value.bracket.chirality;\r\n\r\n      if (edge.chiral === 'up') {\r\n        this.canvasWrapper.drawWedge(new SmilesDrawer.Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else if (edge.chiral === 'down') {\r\n        this.canvasWrapper.drawDashedWedge(new SmilesDrawer.Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else {\r\n        this.canvasWrapper.drawLine(new SmilesDrawer.Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      }\r\n    }\r\n\r\n    if (debug) {\r\n      let midpoint = SmilesDrawer.Vector2.midpoint(a, b);\r\n      this.canvasWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws the vertices representing atoms to the canvas.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.\r\n   */\r\n  drawVertices(debug) {\r\n    var i = this.graph.vertices.length;\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let vertex = this.graph.vertices[i];\r\n      let atom = vertex.value;\r\n      let charge = 0;\r\n      let isotope = 0;\r\n      let bondCount = this.getBondCount(vertex);\r\n      let element = atom.element;\r\n      let hydrogens = SmilesDrawer.Atom.maxBonds[element] - bondCount;\r\n      let dir = vertex.getTextDirection(this.graph.vertices);\r\n      let isTerminal = this.opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;\r\n      let isCarbon = atom.element === 'C';\r\n\r\n      if (atom.bracket) {\r\n        hydrogens = atom.bracket.hcount;\r\n        charge = atom.bracket.charge;\r\n        isotope = atom.bracket.isotope;\r\n      }\r\n\r\n      if (this.opts.atomVisualization === 'allballs') {\r\n        this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n      } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements)) {\r\n        if (this.opts.atomVisualization === 'default') {\r\n          this.canvasWrapper.drawText(vertex.position.x, vertex.position.y,\r\n            element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());\r\n        } else if (this.opts.atomVisualization === 'balls') {\r\n          this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {\r\n        // If there is a carbon which bonds are in a straight line, draw a dot\r\n        let a = this.graph.vertices[vertex.neighbours[0]].position;\r\n        let b = this.graph.vertices[vertex.neighbours[1]].position;\r\n        let angle = SmilesDrawer.Vector2.threePointangle(vertex.position, a, b);\r\n\r\n        if (Math.abs(Math.PI - angle) < 0.1) {\r\n          this.canvasWrapper.drawPoint(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      }\r\n\r\n      if (debug) {\r\n        let value = 'v: ' + vertex.id + ' ' + SmilesDrawer.ArrayHelper.print(atom.ringbonds);\r\n        this.canvasWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);\r\n      }\r\n    }\r\n\r\n    // Draw the ring centers for debug purposes\r\n    if (this.opts.debug) {\r\n      for (var i = 0; i < this.rings.length; i++) {\r\n        let center = this.rings[i].center;\r\n        this.canvasWrapper.drawDebugPoint(center.x, center.y, 'r: ' + this.rings[i].id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Position the vertices according to their bonds and properties.\r\n   */\r\n  position() {\r\n    let startVertex = null;\r\n\r\n    // Always start drawing at a bridged ring if there is one\r\n    // If not, start with a ring\r\n    // else, start with 0\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      if (this.graph.vertices[i].value.bridgedRing !== null) {\r\n        startVertex = this.graph.vertices[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      if (this.rings[i].isBridged) {\r\n        startVertex = this.graph.vertices[this.rings[i].members[0]];\r\n      }\r\n    }\r\n\r\n    if (this.rings.length > 0 && startVertex === null) {\r\n      startVertex = this.graph.vertices[this.rings[0].members[0]];\r\n    }\r\n\r\n    if (startVertex === null) {\r\n      startVertex = this.graph.vertices[0];\r\n    }\r\n\r\n    this.createNextBond(startVertex);\r\n  }\r\n\r\n  /**\r\n   * Stores the current information associated with rings.\r\n   */\r\n  backupRingInformation() {\r\n    this.originalRings = [];\r\n    this.originalRingConnections = [];\r\n\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      this.originalRings.push(this.rings[i]);\r\n    }\r\n\r\n    for (var i = 0; i < this.ringConnections.length; i++) {\r\n      this.originalRingConnections.push(this.ringConnections[i]);\r\n    }\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      this.graph.vertices[i].value.backupRings();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restores the most recently backed up information associated with rings.\r\n   */\r\n  restoreRingInformation() {\r\n    // Get the subring centers from the bridged rings\r\n    let bridgedRings = this.getBridgedRings();\r\n\r\n    this.rings = [];\r\n    this.ringConnections = [];\r\n\r\n    for (var i = 0; i < bridgedRings.length; i++) {\r\n      let bridgedRing = bridgedRings[i];\r\n\r\n      for (var j = 0; j < bridgedRing.rings.length; j++) {\r\n        let ring = bridgedRing.rings[j];\r\n        this.originalRings[ring.id].center = ring.center;\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < this.originalRings.length; i++) {\r\n      this.rings.push(this.originalRings[i]);\r\n    }\r\n\r\n    for (var i = 0; i < this.originalRingConnections.length; i++) {\r\n      this.ringConnections.push(this.originalRingConnections[i]);\r\n    }\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      this.graph.vertices[i].value.restoreRings();\r\n    }\r\n  }\r\n\r\n  // TODO: This needs some cleaning up\r\n\r\n  /**\r\n   * Creates a new ring, that is, positiones all the vertices inside a ring.\r\n   *\r\n   * @param {SmilesDrawer.Ring} ring The ring to position.\r\n   * @param {SmilesDrawer.Vector2|null} [center=null] The center of the ring to be created.\r\n   * @param {SmilesDrawer.Vertex|null} [startVertex=null] The first vertex to be positioned inside the ring.\r\n   * @param {SmilesDrawer.Vertex|null} [previousVertex=null] The last vertex that was positioned.\r\n   * @param {Boolean} [previousVertex=false] A boolean indicating whether or not this ring was force positioned already - this is needed after force layouting a ring, in order to draw rings connected to it.\r\n   */\r\n  createRing(ring, center = null, startVertex = null, previousVertex = null) {\r\n    if (ring.positioned) {\r\n      return;\r\n    }\r\n\r\n    center = center ? center : new SmilesDrawer.Vector2(0, 0);\r\n\r\n    let orderedNeighbours = ring.getOrderedNeighbours(this.ringConnections);\r\n    let startingAngle = startVertex ? SmilesDrawer.Vector2.subtract(startVertex.position, center).angle() : 0;\r\n\r\n    let radius = MathHelper.polyCircumradius(this.opts.bondLength, ring.getSize());\r\n    let angle = MathHelper.centralAngle(ring.getSize());\r\n\r\n    ring.centralAngle = angle;\r\n\r\n    let a = startingAngle;\r\n    let that = this;\r\n    let startVertexId = (startVertex) ? startVertex.id : null;\r\n\r\n    if (ring.members.indexOf(startVertexId) === -1) {\r\n      if (startVertex) {\r\n        startVertex.positioned = false;\r\n      }\r\n\r\n      startVertexId = ring.members[0];\r\n    }\r\n\r\n    // For bridged rings, vertices directly connected to the ring are also positioned.\r\n    let positioned = Array();\r\n\r\n    // If the ring is bridged, then draw the vertices inside the ring\r\n    // using a force based approach\r\n    if (ring.isBridged) {\r\n      this.graph.kkLayout(ring.members.slice(), positioned, center, startVertex.id, ring, this.opts.bondLength);\r\n      ring.positioned = true;\r\n\r\n      // Update the center of the bridged ring\r\n      this.setRingCenter(ring);\r\n      center = ring.center;\r\n\r\n      // Setting the centers for the subrings\r\n      for (var i = 0; i < ring.rings.length; i++) {\r\n        this.setRingCenter(ring.rings[i]);\r\n      }\r\n    } else {\r\n      ring.eachMember(this.graph.vertices, function (v) {\r\n        let vertex = that.graph.vertices[v];\r\n\r\n        if (!vertex.positioned) {\r\n          vertex.setPosition(center.x + Math.cos(a) * radius, center.y + Math.sin(a) * radius);\r\n        }\r\n\r\n        a += angle;\r\n\r\n        if (!ring.isBridged || ring.rings.length < 3) {\r\n          vertex.positioned = true;\r\n        }\r\n      }, startVertexId, (previousVertex) ? previousVertex.id : null);\r\n    }\r\n\r\n    ring.positioned = true;\r\n    ring.center = center;\r\n\r\n    // Draw neighbours in decreasing order of connectivity\r\n    for (var i = 0; i < orderedNeighbours.length; i++) {\r\n      let neighbour = this.getRing(orderedNeighbours[i].neighbour);\r\n\r\n      if (neighbour.positioned) {\r\n        continue;\r\n      }\r\n\r\n      let vertices = SmilesDrawer.RingConnection.getVertices(this.ringConnections, ring.id, neighbour.id);\r\n\r\n      if (vertices.length === 2) {\r\n        // This ring is a fused ring\r\n        ring.isFused = true;\r\n        neighbour.isFused = true;\r\n\r\n        let vertexA = this.graph.vertices[vertices[0]];\r\n        let vertexB = this.graph.vertices[vertices[1]];\r\n\r\n        // Get middle between vertex A and B\r\n        let midpoint = SmilesDrawer.Vector2.midpoint(vertexA.position, vertexB.position);\r\n\r\n        // Get the normals to the line between A and B\r\n        let normals = SmilesDrawer.Vector2.normals(vertexA.position, vertexB.position);\r\n\r\n        // Normalize the normals\r\n        normals[0].normalize();\r\n        normals[1].normalize();\r\n\r\n        // Set length from middle of side to center (the apothem)\r\n        let r = MathHelper.polyCircumradius(this.opts.bondLength, neighbour.getSize());\r\n        let apothem = MathHelper.apothem(r, neighbour.getSize());\r\n\r\n        normals[0].multiplyScalar(apothem).add(midpoint);\r\n        normals[1].multiplyScalar(apothem).add(midpoint);\r\n\r\n        // Pick the normal which results in a larger distance to the previous center\r\n        // Also check whether it's inside another ring\r\n        let nextCenter = normals[0];\r\n        if (SmilesDrawer.Vector2.subtract(center, normals[1]).lengthSq() > SmilesDrawer.Vector2.subtract(center, normals[0]).lengthSq()) {\r\n          nextCenter = normals[1];\r\n        }\r\n\r\n        // Get the vertex (A or B) which is in clock-wise direction of the other\r\n        let posA = SmilesDrawer.Vector2.subtract(vertexA.position, nextCenter);\r\n        let posB = SmilesDrawer.Vector2.subtract(vertexB.position, nextCenter);\r\n\r\n        if (posA.clockwise(posB) === -1) {\r\n          if (!neighbour.positioned) {\r\n            this.createRing(neighbour, nextCenter, vertexA, vertexB);\r\n          }\r\n        } else {\r\n          if (!neighbour.positioned) {\r\n            this.createRing(neighbour, nextCenter, vertexB, vertexA);\r\n          }\r\n        }\r\n      } else if (vertices.length === 1) {\r\n        // This ring is a spiro\r\n        ring.isSpiro = true;\r\n        neighbour.isSpiro = true;\r\n\r\n        let vertexA = this.graph.vertices[vertices[0]];\r\n\r\n        // Get the vector pointing from the shared vertex to the new centpositioner\r\n        let nextCenter = SmilesDrawer.Vector2.subtract(center, vertexA.position);\r\n\r\n        nextCenter.invert();\r\n        nextCenter.normalize();\r\n\r\n        // Get the distance from the vertex to the center\r\n        let r = MathHelper.polyCircumradius(this.opts.bondLength, neighbour.getSize());\r\n\r\n        nextCenter.multiplyScalar(r);\r\n        nextCenter.add(vertexA.position);\r\n\r\n        if (!neighbour.positioned) {\r\n          this.createRing(neighbour, nextCenter, vertexA);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Next, draw atoms that are not part of a ring that are directly attached to this ring\r\n    for (var i = 0; i < ring.members.length; i++) {\r\n      let ringMember = this.graph.vertices[ring.members[i]];\r\n      let ringMemberNeighbours = ringMember.getNeighbours();\r\n\r\n      // If there are multiple, the ovlerap will be resolved in the appropriate step\r\n      for (var j = 0; j < ringMemberNeighbours.length; j++) {\r\n        let v = this.graph.vertices[ringMemberNeighbours[j]];\r\n\r\n        if (v.positioned) {\r\n          continue;\r\n        }\r\n\r\n        v.value.isConnectedToRing = true;\r\n        this.createNextBond(v, ringMember, this.getSubringCenter(ring, ringMember));\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < positioned.length; i++) {\r\n      let u = this.graph.vertices[positioned[i][1]]; // this is the ring vertex\r\n      let v = this.graph.vertices[positioned[i][0]]; // this is the vertex attached to the ring vertex\r\n      v.previousPosition = u.position;\r\n      this.createNextBond(v, u, 0, 0, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotate an entire subtree by an angle around a center.\r\n   *\r\n   * @param {Number} vertexId A vertex id (the root of the sub-tree).\r\n   * @param {Number} parentVertexId A vertex id in the previous direction of the subtree that is to rotate.\r\n   * @param {Number} angle An angle in randians.\r\n   * @param {SmilesDrawer.Vector2} center The rotational center.\r\n   */\r\n  rotateSubtree(vertexId, parentVertexId, angle, center) {\r\n    let that = this;\r\n\r\n    this.traverseTree(vertexId, parentVertexId, function (vertex) {\r\n      vertex.position.rotateAround(angle, center);\r\n\r\n      for (var i = 0; i < vertex.value.anchoredRings.length; i++) {\r\n        let ring = that.rings[vertex.value.anchoredRings[i]];\r\n\r\n        if (ring) {\r\n          ring.center.rotateAround(angle, center);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the overlap score of a subtree.\r\n   *\r\n   * @param {Number} vertexId A vertex id (the root of the sub-tree).\r\n   * @param {Number} parentVertexId A vertex id in the previous direction of the subtree.\r\n   * @param {Number[]} vertexOverlapScores An array containing the vertex overlap scores indexed by vertex id.\r\n   * @returns {Object} An object containing the total overlap score and the center of mass of the subtree weighted by overlap score { value: 0.2, center: new SmilesDrawer.Vector2() }.\r\n   */\r\n  getSubtreeOverlapScore(vertexId, parentVertexId, vertexOverlapScores) {\r\n    let that = this;\r\n    let score = 0;\r\n    let center = new SmilesDrawer.Vector2();\r\n\r\n    this.traverseTree(vertexId, parentVertexId, function (vertex) {\r\n      let s = vertexOverlapScores[vertex.id];\r\n      score += s;\r\n\r\n      let position = that.graph.vertices[vertex.id].position.clone();\r\n      position.multiplyScalar(s)\r\n      center.add(position);\r\n    });\r\n\r\n    center.divide(score);\r\n\r\n    return {\r\n      value: score,\r\n      center: center\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns the current (positioned vertices so far) center of mass.\r\n   * \r\n   * @returns {SmilesDrawer.Vector2} The current center of mass.\r\n   */\r\n  getCurrentCenterOfMass() {\r\n    let total = new SmilesDrawer.Vector2();\r\n    let count = 0;\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let vertex = this.graph.vertices[i];\r\n\r\n      if (vertex.positioned) {\r\n        total.add(vertex.position);\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return total.divide(count);\r\n  }\r\n\r\n  /**\r\n   * Returns the current (positioned vertices so far) center of mass in the neighbourhood of a given position.\r\n   *\r\n   * @param {SmilesDrawer.Vector2} vec The point at which to look for neighbours.\r\n   * @param {Number} [r=currentBondLength*2.0] The radius of vertices to include.\r\n   * @returns {SmilesDrawer.Vector2} The current center of mass.\r\n   */\r\n  getCurrentCenterOfMassInNeigbourhood(vec, r = this.opts.bondLength * 2.0) {\r\n    let total = new SmilesDrawer.Vector2();\r\n    let count = 0;\r\n    let rSq = r * r;\r\n\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let vertex = this.graph.vertices[i];\r\n\r\n      if (vertex.positioned && vec.distanceSq(vertex.position) < rSq) {\r\n        total.add(vertex.position);\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return total.divide(count);\r\n  }\r\n\r\n  /**\r\n   * Resolve primary (exact) overlaps, such as two vertices that are connected to the same ring vertex.\r\n   */\r\n  resolvePrimaryOverlaps() {\r\n    let overlaps = [];\r\n    let done = Array(this.graph.vertices.length);\r\n\r\n    // Looking for overlaps created by two bonds coming out of a ring atom, which both point straight\r\n    // away from the ring and are thus perfectly overlapping.\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      let ring = this.rings[i];\r\n\r\n      for (var j = 0; j < ring.members.length; j++) {\r\n        let vertex = this.graph.vertices[ring.members[j]];\r\n\r\n        if (done[vertex.id]) {\r\n          continue;\r\n        }\r\n\r\n        done[vertex.id] = true;\r\n\r\n        // Look for rings where there are atoms with two bonds outside the ring (overlaps)\r\n        let nonRingNeighbours = this.getNonRingNeighbours(vertex.id);\r\n\r\n        if (nonRingNeighbours.length > 1) {\r\n          let rings = [];\r\n\r\n          for (var k = 0; k < vertex.value.rings.length; k++) {\r\n            rings.push(vertex.value.rings[k]);\r\n          }\r\n\r\n          overlaps.push({\r\n            common: vertex,\r\n            rings: rings,\r\n            vertices: nonRingNeighbours\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < overlaps.length; i++) {\r\n      let overlap = overlaps[i];\r\n    \r\n      if (overlap.vertices.length === 2) {\r\n        let a = overlap.vertices[0];\r\n        let b = overlap.vertices[1];\r\n\r\n        if (!a.value.isDrawn || !b.value.isDrawn) {\r\n            continue;\r\n        }\r\n\r\n        let angle = (2 * Math.PI - this.getRing(overlap.rings[0]).getAngle()) / 6.0;\r\n\r\n        this.rotateSubtree(a.id, overlap.common.id, angle, overlap.common.position);\r\n        this.rotateSubtree(b.id, overlap.common.id, -angle, overlap.common.position);\r\n\r\n        // Decide which way to rotate the vertices depending on the effect it has on the overlap score\r\n        let overlapScore = this.getOverlapScore();        \r\n        let subTreeOverlapA = this.getSubtreeOverlapScore(a.id, overlap.common.id, overlapScore.vertexScores);\r\n        let subTreeOverlapB = this.getSubtreeOverlapScore(b.id, overlap.common.id, overlapScore.vertexScores);\r\n        let total = subTreeOverlapA.value + subTreeOverlapB.value;\r\n\r\n        this.rotateSubtree(a.id, overlap.common.id, -2.0 * angle, overlap.common.position);\r\n        this.rotateSubtree(b.id, overlap.common.id, 2.0 * angle, overlap.common.position);\r\n\r\n        overlapScore = this.getOverlapScore();        \r\n        subTreeOverlapA = this.getSubtreeOverlapScore(a.id, overlap.common.id, overlapScore.vertexScores);\r\n        subTreeOverlapB = this.getSubtreeOverlapScore(b.id, overlap.common.id, overlapScore.vertexScores);\r\n        \r\n        if (subTreeOverlapA.value + subTreeOverlapB.value > total) {\r\n            this.rotateSubtree(a.id, overlap.common.id, 2.0 * angle, overlap.common.position);\r\n            this.rotateSubtree(b.id, overlap.common.id, -2.0 * angle, overlap.common.position);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resolve secondary overlaps. Those overlaps are due to the structure turning back on itself.\r\n   *\r\n   * @param {Object[]} scores An array of objects sorted descending by score.\r\n   * @param {Number} scores[].id A vertex id.\r\n   * @param {Number} scores[].score The overlap score associated with the vertex id.\r\n   */\r\n  resolveSecondaryOverlaps(scores) {\r\n    for (var i = 0; i < scores.length; i++) {\r\n      if (scores[i].score > this.opts.bondLength / (4.0 * this.opts.bondLength)) {\r\n        let vertex = this.graph.vertices[scores[i].id];\r\n\r\n        if (vertex.isTerminal()) {\r\n          let closest = this.getClosestVertex(vertex);\r\n\r\n          if (closest) {\r\n            // If one of the vertices is the first one, the previous vertex is not the central vertex but the dummy\r\n            // so take the next rather than the previous, which is vertex 1\r\n            let closestPosition = null;\r\n\r\n            if (closest.isTerminal()) {\r\n              closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.previousPosition\r\n            } else {\r\n              closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.position\r\n            }\r\n\r\n            let vertexPreviousPosition = vertex.id === 0 ? this.graph.vertices[1].position : vertex.previousPosition;\r\n\r\n            vertex.position.rotateAwayFrom(closestPosition, vertexPreviousPosition, MathHelper.toRad(20));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Positiones the next vertex thus creating a bond.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertex A vertex.\r\n   * @param {SmilesDrawer.Vertex} previousVertex The previous vertex which has been positioned.\r\n   * @param {SmilesDrawer.Ring|Number} ringOrAngle Either a ring or a number. If the vertex is connected to a ring, it is positioned based on the ring center and thus the ring is supplied. If the vertex is not in a ring, an angle (in radians) is supplied.\r\n   * @param {Number} dir Either 1 or -1 to break ties (if no angle can be elucidated).\r\n   * @param {Boolean} [skipPositioning=false] Whether or not to skip positioning and just check the neighbours.\r\n   */\r\n  createNextBond(vertex, previousVertex, ringOrAngle, dir, skipPositioning = false) {\r\n    if (vertex.positioned && !skipPositioning) {\r\n      return;\r\n    }\r\n\r\n    // If the current node is the member of one ring, then point straight away\r\n    // from the center of the ring. However, if the current node is a member of\r\n    // two rings, point away from the middle of the centers of the two rings\r\n    if (!skipPositioning) {\r\n      if (!previousVertex) {\r\n        // Here, ringOrAngle is always an angle\r\n\r\n        // Add a (dummy) previous position if there is no previous vertex defined\r\n        // Since the first vertex is at (0, 0), create a vector at (bondLength, 0)\r\n        // and rotate it by 90\r\n\r\n\r\n        let dummy = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n        dummy.rotate(MathHelper.toRad(-120));\r\n\r\n        vertex.previousPosition = dummy;\r\n        vertex.setPosition(this.opts.bondLength, 0);\r\n        vertex.angle = MathHelper.toRad(-120);\r\n        vertex.globalAngle = vertex.angle;\r\n\r\n        // Do not position the vertex if it belongs to a bridged ring that is positioned using a layout algorithm.\r\n        if (vertex.value.bridgedRing === null) {\r\n          vertex.positioned = true;\r\n        }\r\n      } else if (previousVertex.value.originalRings.length === 1) {\r\n        let vecs = Array()\r\n        let neighbours = previousVertex.getNeighbours();\r\n\r\n        for (var i = 0; i < neighbours.length; i++) {\r\n          let neighbour = this.graph.vertices[neighbours[i]];\r\n\r\n          if (neighbour.positioned && neighbour.value.originalRings.length > 0) {\r\n            vecs.push(SmilesDrawer.Vector2.subtract(neighbour.position, previousVertex.position));\r\n          }\r\n        }\r\n\r\n        let avg = SmilesDrawer.Vector2.averageDirection(vecs);\r\n        vertex.setPositionFromVector(avg.invert().multiplyScalar(this.opts.bondLength).add(previousVertex.position));\r\n        vertex.previousPosition = previousVertex.position;\r\n        vertex.positioned = true;\r\n      } else if (previousVertex.value.originalRings.length > 1) {\r\n        let vecs = Array()\r\n        let neighbours = previousVertex.getNeighbours();\r\n        \r\n        for (var i = 0; i < neighbours.length; i++) {\r\n          let neighbour = this.graph.vertices[neighbours[i]];\r\n          \r\n          if (neighbour.positioned && neighbour.value.originalRings.length > 1) {\r\n            vecs.push(SmilesDrawer.Vector2.subtract(neighbour.position, previousVertex.position));\r\n          }\r\n        }\r\n\r\n        let avg = SmilesDrawer.Vector2.averageDirection(vecs);\r\n        avg.invert().multiplyScalar(this.opts.bondLength).add(previousVertex.position);\r\n\r\n        // Invert if too close to another of the averaged vertices (resolve situations like: CC1CC2NCC3(N)CC1(C)C23CC#C)\r\n        for (var i = 0; i < neighbours.length; i++) {\r\n          let neighbour = this.graph.vertices[neighbours[i]];\r\n\r\n          if (!neighbour.positioned) {\r\n            continue;\r\n          }\r\n\r\n          if (SmilesDrawer.Vector2.threePointangle(avg, previousVertex.position, neighbour.position) > 3.1) {\r\n            avg.rotateAround(Math.PI, previousVertex.position);\r\n            break;\r\n          }\r\n        }\r\n\r\n        vertex.previousPosition = previousVertex.position;\r\n        vertex.setPositionFromVector(avg);\r\n        vertex.positioned = true;\r\n      } else {\r\n        // Here, ringOrAngle is always an angle\r\n\r\n        // If the previous vertex was not part of a ring, draw a bond based\r\n        // on the global angle of the previous bond\r\n        let v = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n        v.rotate(ringOrAngle);\r\n        v.add(previousVertex.position);\r\n\r\n        vertex.globalAngle = ringOrAngle;\r\n        vertex.setPositionFromVector(v);\r\n        vertex.previousPosition = previousVertex.position;\r\n        vertex.positioned = true;\r\n      }\r\n    }\r\n\r\n    // Go to next vertex\r\n    // If two rings are connected by a bond ...\r\n    if (vertex.value.bridgedRing !== null) {\r\n      let nextRing = this.getRing(vertex.value.bridgedRing);\r\n      let nextCenter = SmilesDrawer.Vector2.subtract(vertex.previousPosition, vertex.position);\r\n\r\n      nextCenter.invert();\r\n      nextCenter.normalize();\r\n\r\n      let r = MathHelper.polyCircumradius(this.opts.bondLength, nextRing.members.length);\r\n      nextCenter.multiplyScalar(r);\r\n      nextCenter.add(vertex.position);\r\n\r\n\r\n      if (!nextRing.positioned) {\r\n        this.createRing(nextRing, nextCenter, vertex);\r\n      }\r\n    } else if (vertex.value.rings.length > 0) {\r\n      let nextRing = this.getRing(vertex.value.rings[0]);\r\n      let nextCenter = SmilesDrawer.Vector2.subtract(vertex.previousPosition, vertex.position);\r\n\r\n      nextCenter.invert();\r\n      nextCenter.normalize();\r\n\r\n      let r = MathHelper.polyCircumradius(this.opts.bondLength, nextRing.getSize());\r\n\r\n      nextCenter.multiplyScalar(r);\r\n      nextCenter.add(vertex.position);\r\n\r\n      if (!nextRing.positioned) {\r\n        this.createRing(nextRing, nextCenter, vertex);\r\n      }\r\n    } else {\r\n      // Draw the non-ring vertices connected to this one        \r\n      let neighbours = vertex.getNeighbours();\r\n\r\n      if (previousVertex) {\r\n        neighbours = SmilesDrawer.ArrayHelper.remove(neighbours, previousVertex.id);\r\n      }\r\n\r\n      let angle = vertex.getAngle();\r\n      \r\n      if (neighbours.length === 1) {\r\n        let nextVertex = this.graph.vertices[neighbours[0]];\r\n\r\n        // Make a single chain always cis except when there's a tribble (yes, this is a Star Trek reference) bond\r\n        // or if there are successive double bonds\r\n        if ((vertex.value.bondType === '#' || (previousVertex && previousVertex.value.bondType === '#')) ||\r\n          vertex.value.bondType === '=' && previousVertex && previousVertex.value.bondType === '=') {\r\n          vertex.value.drawExplicit = false;\r\n\r\n          if (previousVertex) {\r\n            let straightEdge1 = this.graph.getEdge(vertex.id, previousVertex.id);\r\n            straightEdge1.center = true;\r\n          }\r\n\r\n          let straightEdge2 = this.graph.getEdge(vertex.id, nextVertex.id);\r\n          straightEdge2.center = true;\r\n\r\n          nextVertex.drawExplicit = true;\r\n          nextVertex.globalAngle = angle;\r\n          nextVertex.angle = 0.0;\r\n          this.createNextBond(nextVertex, vertex, nextVertex.globalAngle, -dir);\r\n        } else if (previousVertex && previousVertex.value.rings.length > 0) {\r\n          // If coming out of a ring, always draw away from the center of mass\r\n          let proposedAngleA = MathHelper.toRad(60);\r\n          let proposedAngleB = -proposedAngleA;\r\n\r\n          let proposedVectorA = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n          let proposedVectorB = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n\r\n          proposedVectorA.rotate(proposedAngleA).add(vertex.position);\r\n          proposedVectorB.rotate(proposedAngleB).add(vertex.position);\r\n\r\n          // let centerOfMass = this.getCurrentCenterOfMassInNeigbourhood(vertex.position, 100);\r\n          let centerOfMass = this.getCurrentCenterOfMass();\r\n          let distanceA = proposedVectorA.distanceSq(centerOfMass);\r\n          let distanceB = proposedVectorB.distanceSq(centerOfMass);\r\n\r\n          nextVertex.angle = distanceA < distanceB ? proposedAngleB : proposedAngleA;\r\n\r\n          if (nextVertex.angle > 0) {\r\n            dir = -1;\r\n          } else {\r\n            dir = 1;\r\n          }\r\n\r\n          nextVertex.globalAngle = angle + nextVertex.angle;\r\n          this.createNextBond(nextVertex, vertex, nextVertex.globalAngle, dir);\r\n        } else {\r\n          if (!dir) {\r\n            let proposedAngleA = MathHelper.toRad(60);\r\n            let proposedAngleB = -proposedAngleA;\r\n\r\n            let proposedVectorA = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n            let proposedVectorB = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n\r\n            proposedVectorA.rotate(proposedAngleA).add(vertex.position);\r\n            proposedVectorB.rotate(proposedAngleB).add(vertex.position);\r\n\r\n            let centerOfMass = this.getCurrentCenterOfMass();\r\n            let distanceA = proposedVectorA.distanceSq(centerOfMass);\r\n            let distanceB = proposedVectorB.distanceSq(centerOfMass);\r\n\r\n            nextVertex.angle = distanceA < distanceB ? proposedAngleB : proposedAngleA;\r\n\r\n            if (nextVertex.angle > 0) {\r\n              dir = -1;\r\n            } else {\r\n              dir = 1;\r\n            }\r\n          } else {\r\n            nextVertex.angle = MathHelper.toRad(60) * dir;\r\n            dir = -dir;\r\n          }\r\n\r\n          nextVertex.globalAngle = angle + nextVertex.angle;\r\n          this.createNextBond(nextVertex, vertex, nextVertex.globalAngle, dir);\r\n        }\r\n      } else if (neighbours.length === 2) {\r\n        // Check for the longer subtree - always go with cis for the longer subtree\r\n        let subTreeDepthA = this.getTreeDepth(neighbours[0], vertex.id);\r\n        let subTreeDepthB = this.getTreeDepth(neighbours[1], vertex.id);\r\n\r\n        // Also get the subtree for the previous direction (this is important when\r\n        // the previous vertex is the shortest path)\r\n        let subTreeDepthC = this.getTreeDepth(previousVertex ? previousVertex.id : null, vertex.id);\r\n\r\n        let cis = 0;\r\n        let trans = 1;\r\n\r\n        if (subTreeDepthA > subTreeDepthB) {\r\n          cis = 1;\r\n          trans = 0;\r\n        }\r\n\r\n        let cisVertex = this.graph.vertices[neighbours[cis]];\r\n        let transVertex = this.graph.vertices[neighbours[trans]];\r\n\r\n        // If the origin tree is the shortest, set both vertices to trans\r\n        if (subTreeDepthC < subTreeDepthA && subTreeDepthC < subTreeDepthB) {\r\n          if (vertex.position.clockwise(vertex.previousPosition) === 1) {\r\n            transVertex.angle = MathHelper.toRad(60);\r\n            cisVertex.angle = -MathHelper.toRad(60);\r\n            transVertex.globalAngle = angle + transVertex.angle;\r\n            cisVertex.globalAngle = angle + cisVertex.angle;\r\n\r\n            this.createNextBond(transVertex, vertex, transVertex.globalAngle, -dir);\r\n            this.createNextBond(cisVertex, vertex, cisVertex.globalAngle, dir);\r\n          } else {\r\n            transVertex.angle = -MathHelper.toRad(60);\r\n            cisVertex.angle = MathHelper.toRad(60);\r\n            transVertex.globalAngle = angle + transVertex.angle;\r\n            cisVertex.globalAngle = angle + cisVertex.angle;\r\n\r\n            this.createNextBond(cisVertex, vertex, cisVertex.globalAngle, dir);\r\n            this.createNextBond(transVertex, vertex, transVertex.globalAngle, -dir);\r\n          }\r\n        } else {\r\n          if (vertex.position.clockwise(vertex.previousPosition) === 1) {\r\n            transVertex.angle = MathHelper.toRad(60);\r\n            cisVertex.angle = -MathHelper.toRad(60);\r\n            transVertex.globalAngle = angle + transVertex.angle;\r\n            cisVertex.globalAngle = angle + cisVertex.angle;\r\n\r\n            this.createNextBond(transVertex, vertex, transVertex.globalAngle, -dir);\r\n            this.createNextBond(cisVertex, vertex, cisVertex.globalAngle, -dir);\r\n          } else {\r\n            transVertex.angle = -MathHelper.toRad(60);\r\n            cisVertex.angle = MathHelper.toRad(60);\r\n            transVertex.globalAngle = angle + transVertex.angle;\r\n            cisVertex.globalAngle = angle + cisVertex.angle;\r\n\r\n            this.createNextBond(cisVertex, vertex, cisVertex.globalAngle, -dir);\r\n            this.createNextBond(transVertex, vertex, transVertex.globalAngle, -dir);\r\n          }\r\n        }\r\n      } else if (neighbours.length === 3) {\r\n        // The vertex with the longest sub-tree should always go straight\r\n        let d1 = this.getTreeDepth(neighbours[0], vertex.id);\r\n        let d2 = this.getTreeDepth(neighbours[1], vertex.id);\r\n        let d3 = this.getTreeDepth(neighbours[2], vertex.id);\r\n\r\n        let s = this.graph.vertices[neighbours[0]];\r\n        let l = this.graph.vertices[neighbours[1]];\r\n        let r = this.graph.vertices[neighbours[2]];\r\n\r\n        if (d2 > d1 && d2 > d3) {\r\n          s = this.graph.vertices[neighbours[1]];\r\n          l = this.graph.vertices[neighbours[0]];\r\n          r = this.graph.vertices[neighbours[2]];\r\n        } else if (d3 > d1 && d3 > d2) {\r\n          s = this.graph.vertices[neighbours[2]];\r\n          l = this.graph.vertices[neighbours[0]];\r\n          r = this.graph.vertices[neighbours[1]];\r\n        }\r\n\r\n        if (this.getTreeDepth(l.id, vertex.id) === 1 &&\r\n          this.getTreeDepth(r.id, vertex.id) === 1 &&\r\n          this.getTreeDepth(s.id, vertex.id) > 1) {\r\n\r\n          if (!dir) {\r\n            let proposedAngleA = MathHelper.toRad(60);\r\n            let proposedAngleB = -proposedAngleA;\r\n\r\n            let proposedVectorA = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n            let proposedVectorB = new SmilesDrawer.Vector2(this.opts.bondLength, 0);\r\n\r\n            proposedVectorA.rotate(proposedAngleA).add(vertex.position);\r\n            proposedVectorB.rotate(proposedAngleB).add(vertex.position);\r\n\r\n            // let centerOfMass = this.getCurrentCenterOfMassInNeigbourhood(vertex.position, 100);\r\n            let centerOfMass = this.getCurrentCenterOfMass();\r\n            let distanceA = proposedVectorA.distanceSq(centerOfMass);\r\n            let distanceB = proposedVectorB.distanceSq(centerOfMass);\r\n\r\n            s.angle = distanceA < distanceB ? proposedAngleB : proposedAngleA;\r\n\r\n            if (s.angle > 0) {\r\n              dir = -1;\r\n            } else {\r\n              dir = 1;\r\n            }\r\n          } else {\r\n            s.angle = MathHelper.toRad(60) * dir;\r\n            dir = -dir;\r\n          }\r\n\r\n          s.globalAngle = angle + s.angle;\r\n\r\n          this.createNextBond(s, vertex, s.globalAngle, -dir);\r\n\r\n          // If it's chiral, the order changes - for anticlockwise, switch the draw order around\r\n          // to keep the drawing the same\r\n          if (vertex.value.bracket && vertex.value.bracket.chirality === '@@') {\r\n            r.angle = MathHelper.toRad(30) * dir;\r\n            l.angle = MathHelper.toRad(90) * dir;\r\n\r\n            r.globalAngle = angle + r.angle;\r\n            l.globalAngle = angle + l.angle;\r\n\r\n            this.createNextBond(r, vertex, r.globalAngle);\r\n            this.createNextBond(l, vertex, l.globalAngle);\r\n          } else {\r\n            l.angle = MathHelper.toRad(30) * dir;\r\n            r.angle = MathHelper.toRad(90) * dir;\r\n\r\n            l.globalAngle = angle + l.angle;\r\n            r.globalAngle = angle + r.angle;\r\n\r\n            this.createNextBond(l, vertex, l.globalAngle);\r\n            this.createNextBond(r, vertex, r.globalAngle);\r\n          }\r\n        } else {\r\n          s.angle = 0.0;\r\n          l.angle = MathHelper.toRad(90);\r\n          r.angle = -MathHelper.toRad(90);\r\n\r\n          s.globalAngle = angle + s.angle;\r\n          l.globalAngle = angle + l.angle;\r\n          r.globalAngle = angle + r.angle;\r\n\r\n          this.createNextBond(s, vertex, s.globalAngle);\r\n          this.createNextBond(l, vertex, l.globalAngle);\r\n          this.createNextBond(r, vertex, r.globalAngle);\r\n        }\r\n      } else if (neighbours.length === 4) {\r\n        // The vertex with the longest sub-tree should always go to the reflected opposide direction\r\n        let d1 = this.getTreeDepth(neighbours[0], vertex.id);\r\n        let d2 = this.getTreeDepth(neighbours[1], vertex.id);\r\n        let d3 = this.getTreeDepth(neighbours[2], vertex.id);\r\n        let d4 = this.getTreeDepth(neighbours[3], vertex.id);\r\n\r\n        let w = this.graph.vertices[neighbours[0]];\r\n        let x = this.graph.vertices[neighbours[1]];\r\n        let y = this.graph.vertices[neighbours[2]];\r\n        let z = this.graph.vertices[neighbours[3]];\r\n\r\n        if (d2 > d1 && d2 > d3 && d2 > d4) {\r\n          w = this.graph.vertices[neighbours[1]];\r\n          x = this.graph.vertices[neighbours[0]];\r\n          y = this.graph.vertices[neighbours[2]];\r\n          z = this.graph.vertices[neighbours[3]];\r\n        } else if (d3 > d1 && d3 > d2 && d3 > d4) {\r\n          w = this.graph.vertices[neighbours[2]];\r\n          x = this.graph.vertices[neighbours[0]];\r\n          y = this.graph.vertices[neighbours[1]];\r\n          z = this.graph.vertices[neighbours[3]];\r\n        } else if (d4 > d1 && d4 > d2 && d4 > d3) {\r\n          w = this.graph.vertices[neighbours[3]];\r\n          x = this.graph.vertices[neighbours[0]];\r\n          y = this.graph.vertices[neighbours[1]];\r\n          z = this.graph.vertices[neighbours[2]];\r\n        }\r\n\r\n        w.angle = -MathHelper.toRad(36);\r\n        x.angle = MathHelper.toRad(36);\r\n        y.angle = -MathHelper.toRad(108);\r\n        z.angle = MathHelper.toRad(108);\r\n\r\n        w.globalAngle = angle + w.angle;\r\n        x.globalAngle = angle + x.angle;\r\n        y.globalAngle = angle + y.angle;\r\n        z.globalAngle = angle + z.angle;\r\n\r\n        this.createNextBond(w, vertex, w.globalAngle);\r\n        this.createNextBond(x, vertex, x.globalAngle);\r\n        this.createNextBond(y, vertex, y.globalAngle);\r\n        this.createNextBond(z, vertex, z.globalAngle);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the vetex sharing the edge that is the common bond of two rings.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertex A vertex.\r\n   * @returns {Number|null} The id of a vertex sharing the edge that is the common bond of two rings with the vertex provided or null, if none.\r\n   */\r\n  getCommonRingbondNeighbour(vertex) {\r\n    let neighbours = vertex.getNeighbours();\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      let neighbour = this.graph.vertices[neighbours[i]];\r\n\r\n      if (SmilesDrawer.ArrayHelper.All(neighbour.value.rings, vertex.value.rings)) {\r\n        return neighbour;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if a vector is inside any ring.\r\n   *\r\n   * @param {SmilesDrawer.Vector2} vec A vector.\r\n   * @returns {Boolean} A boolean indicating whether or not the point (vector) is inside any of the rings associated with the current molecule.\r\n   */\r\n  isPointInRing(vec) {\r\n    for (var i = 0; i < this.rings.length; i++) {\r\n      let ring = this.rings[i];\r\n\r\n      if (!ring.positioned) {\r\n        continue;\r\n      }\r\n\r\n      let radius = MathHelper.polyCircumradius(this.opts.bondLength, ring.getSize());\r\n      let radiusSq = radius * radius;\r\n\r\n      if (vec.distanceSq(ring.center) < radiusSq) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check whether or not an edge is part of a ring.\r\n   *\r\n   * @param {SmilesDrawer.Edge} edge An edge.\r\n   * @returns {Boolean} A boolean indicating whether or not the edge is part of a ring.\r\n   */\r\n  isEdgeInRing(edge) {\r\n    let source = this.graph.vertices[edge.sourceId];\r\n    let target = this.graph.vertices[edge.targetId];\r\n\r\n    return this.areVerticesInSameRing(source, target);\r\n  }\r\n\r\n  /**\r\n   * Check whether or not an edge is rotatable.\r\n   *\r\n   * @param {SmilesDrawer.Edge} edge An edge.\r\n   * @returns {Boolean} A boolean indicating whether or not the edge is rotatable.\r\n   */\r\n  isEdgeRotatable(edge) {\r\n    let vertexA = this.graph.vertices[edge.sourceId];\r\n    let vertexB = this.graph.vertices[edge.targetId];\r\n\r\n    // Only single bonds are rotatable\r\n    if (edge.bondType !== '-') {\r\n      return false;\r\n    }\r\n\r\n    // Do not rotate edges that have a further single bond to each side\r\n    // If the bond is terminal, it doesn't make sense to rotate it\r\n    if (vertexA.getNeighbourCount() + vertexB.getNeighbourCount() < 5) {\r\n      return false;\r\n    }\r\n\r\n    // Ringbonds are not rotatable\r\n    if (vertexA.value.rings.length > 0 && vertexB.value.rings.length > 0 &&\r\n      this.areVerticesInSameRing(vertexA, vertexB)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check whether or not a ring is an implicitly defined aromatic ring (lower case smiles).\r\n   *\r\n   * @param {SmilesDrawer.Ring} ring A ring.\r\n   * @returns {Boolean} A boolean indicating whether or not a ring is implicitly defined as aromatic.\r\n   */\r\n  isRingAromatic(ring) {\r\n    for (var i = 0; i < ring.members.length; i++) {\r\n      let vertex = this.graph.vertices[ring.members[i]];\r\n\r\n      if (!vertex.value.isPartOfAromaticRing) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get the normals of an edge.\r\n   *\r\n   * @param {SmilesDrawer.Edge} edge An edge.\r\n   * @returns {SmilesDrawer.Vector2[]} An array containing two vectors, representing the normals.\r\n   */\r\n  getEdgeNormals(edge) {\r\n    let v1 = this.graph.vertices[edge.sourceId].position;\r\n    let v2 = this.graph.vertices[edge.targetId].position;\r\n\r\n    // Get the normalized normals for the edge\r\n    let normals = SmilesDrawer.Vector2.units(v1, v2);\r\n\r\n    return normals;\r\n  }\r\n\r\n  /**\r\n   * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId The id of a neighbouring vertex.\r\n   * @returns {Number} The depth of the sub-tree.\r\n   */\r\n  getTreeDepth(vertexId, parentVertexId) {\r\n    if (vertexId === null || parentVertexId === null) {\r\n      return 0;\r\n    }\r\n\r\n    let neighbours = this.graph.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);\r\n    let max = 0;\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      let childId = neighbours[i];\r\n      let d = this.getTreeDepth(childId, vertexId);\r\n\r\n      if (d > max) {\r\n        max = d;\r\n      }\r\n    }\r\n\r\n    return max + 1;\r\n  }\r\n\r\n  /**\r\n   * Traverse a sub-tree in the graph.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId A neighbouring vertex.\r\n   * @param {Function} callback The callback function that is called with each visited as an argument.\r\n   * @param {Number} [maxDepth=null] The maximum depth of the recursion. If null, there is no limit.\r\n   * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.\r\n   */\r\n  traverseTree(vertexId, parentVertexId, callback, maxDepth = null, ignoreFirst = false, depth = 1, visited = []) {\r\n    if (maxDepth !== null && depth > maxDepth + 1) {\r\n      return;\r\n    }\r\n\r\n    for (var j = 0; j < visited.length; j++) {\r\n      if (visited[j] === vertexId) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    visited.push(vertexId);\r\n\r\n    let vertex = this.graph.vertices[vertexId];\r\n    let neighbours = vertex.getNeighbours(parentVertexId);\r\n\r\n    if (!ignoreFirst || depth > 1) {\r\n      callback(vertex);\r\n    }\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the number of bonds of a vertex.\r\n   *\r\n   * @param {SmilesDrawer.Vertex} vertex A vertex.\r\n   * @returns {Number} The number of bonds the vertex participates in.\r\n   */\r\n  getBondCount(vertex) {\r\n    let count = 0;\r\n\r\n    for (var i = 0; i < vertex.edges.length; i++) {\r\n      count += this.graph.edges[vertex.edges[i]].getBondCount();\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of vertices that are neighbouring a vertix but are not members of a ring (including bridges).\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @returns {SmilesDrawer.Vertex[]} An array of vertices.\r\n   */\r\n  getNonRingNeighbours(vertexId) {\r\n    let nrneighbours = [];\r\n    let vertex = this.graph.vertices[vertexId];\r\n    let neighbours = vertex.getNeighbours();\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      let neighbour = this.graph.vertices[neighbours[i]];\r\n      let nIntersections = SmilesDrawer.ArrayHelper.intersection(vertex.value.rings, neighbour.value.rings).length;\r\n\r\n      if (nIntersections === 0 && neighbour.value.isBridge == false) {\r\n        nrneighbours.push(neighbour);\r\n      }\r\n    }\r\n\r\n    return nrneighbours;\r\n  }\r\n\r\n  annotateStereochemistry() {\r\n    let maxDepth = 10;\r\n    // For each stereo-center\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      let vertex = this.graph.vertices[i];\r\n      \r\n      if (!vertex.value.bracket || !vertex.value.bracket.chirality) {\r\n        continue;\r\n      }\r\n\r\n      let neighbours = vertex.getNeighbours();\r\n      neighbours.sort();\r\n      let nNeighbours = neighbours.length;\r\n      let priorities = Array(nNeighbours);\r\n\r\n      for (var j = 0; j < nNeighbours; j++) {\r\n        let visited = new Uint8Array(this.graph.vertices.length);\r\n        let priority = new Uint16Array(maxDepth * 2.0 + 1);\r\n        visited[vertex.id] = 1;\r\n        this.visitStereochemistry(neighbours[j], visited, priority, maxDepth, 0);\r\n        \r\n        // Break ties by the position in the smiles string as per specification\r\n        priority[maxDepth * 2.0] = neighbours[j];\r\n        priorities[j] = [ j, priority ];\r\n      }\r\n\r\n      priorities.sort(function(a, b) {\r\n        for (var j = 0; j < nNeighbours; j++) {\r\n          if (a[1][j] > b[1][j]) {\r\n            return -1;\r\n          } else if (a[1][j] < b[1][j]) {\r\n            return 1;\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      });\r\n\r\n      let order = new Uint8Array(nNeighbours);\r\n      for (var j = 0; j < nNeighbours; j++) {\r\n        order[j] = priorities[j][0];\r\n      }\r\n\r\n      console.log(order);\r\n      console.log(vertex.id, MathHelper.parityOfPermutation(order));\r\n    }\r\n  }\r\n\r\n  visitStereochemistry(vertexId, visited, priority, maxDepth, depth) {\r\n    visited[vertexId] = 1;\r\n    let atomicNumber = this.graph.vertices[vertexId].value.getAtomicNumber();\r\n\r\n    priority[maxDepth + depth] += atomicNumber;\r\n    priority[depth] = Math.max(priority[depth], atomicNumber);\r\n\r\n    let neighbours = this.graph.vertices[vertexId].getNeighbours();\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      if (visited[neighbours[i]] !== 1 && depth < maxDepth - 1) {\r\n        this.visitStereochemistry(neighbours[i], visited, priority, maxDepth, depth + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates pseudo-elements (such as Et, Me, Ac, Bz, ...) at the position of the carbon sets\r\n   * the involved atoms not to be displayed.\r\n   */\r\n  initPseudoElements() {\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      const vertex = this.graph.vertices[i];\r\n      const neighbourIds = vertex.getNeighbours();\r\n      let neighbours = [];\r\n\r\n      for (var j = 0; j < neighbourIds.length; j++) {\r\n        neighbours.push(this.graph.vertices[neighbourIds[j]]);\r\n      }\r\n\r\n      // Ignore atoms that have less than 3 neighbours, except if\r\n      // the vertex is connected to a ring and has two neighbours\r\n      if (vertex.getNeighbourCount() < 3 || vertex.value.rings.length > 0) {\r\n        continue;\r\n      }\r\n\r\n      // Continue if there are less than two heteroatoms\r\n      // or if a neighbour has more than 1 neighbour\r\n      let heteroAtomCount = 0;\r\n      let ctn = 0;\r\n\r\n      for (var j = 0; j < neighbours.length; j++) {\r\n        let neighbour = neighbours[j];\r\n        let neighbouringElement = neighbour.value.element;\r\n        let neighbourCount = neighbour.getNeighbourCount();\r\n\r\n        if (neighbouringElement !== 'C' && neighbouringElement !== 'H' &&\r\n          neighbourCount === 1) {\r\n          heteroAtomCount++;\r\n        }\r\n\r\n        if (neighbourCount > 1) {\r\n          ctn++;\r\n        }\r\n      }\r\n\r\n      if (ctn > 1 || heteroAtomCount < 2) {\r\n        continue;\r\n      }\r\n\r\n      // Get the previous atom (the one which is not terminal)\r\n      let previous = null;\r\n\r\n      for (var j = 0; j < neighbours.length; j++) {\r\n        let neighbour = neighbours[j];\r\n\r\n        if (neighbour.getNeighbourCount() > 1) {\r\n          previous = neighbour;\r\n        }\r\n      }\r\n\r\n      for (var j = 0; j < neighbours.length; j++) {\r\n        let neighbour = neighbours[j];\r\n\r\n        if (neighbour.getNeighbourCount() > 1) {\r\n          continue;\r\n        }\r\n\r\n        neighbour.value.isDrawn = false;\r\n\r\n        let hydrogens = SmilesDrawer.Atom.maxBonds[neighbour.value.element] - this.getBondCount(neighbour);\r\n\r\n        if (neighbour.value.bracket) {\r\n          hydrogens = neighbour.value.bracket.hcount;\r\n        }\r\n\r\n        vertex.value.attachPseudoElement(neighbour.value.element, previous ? previous.value.element : null, hydrogens);\r\n      }\r\n    }\r\n\r\n    // The second pass\r\n    for (var i = 0; i < this.graph.vertices.length; i++) {\r\n      const vertex = this.graph.vertices[i];\r\n      const atom = vertex.value;\r\n      const element = atom.element;\r\n\r\n      if (element === 'C' || element === 'H' || !atom.isDrawn) {\r\n        continue;\r\n      }\r\n\r\n      const neighbourIds = vertex.getNeighbours();\r\n      let neighbours = [];\r\n\r\n      for (var j = 0; j < neighbourIds.length; j++) {\r\n        neighbours.push(this.graph.vertices[neighbourIds[j]]);\r\n      }\r\n\r\n      for (var j = 0; j < neighbours.length; j++) {\r\n        let neighbour = neighbours[j].value;\r\n\r\n        if (!neighbour.hasAttachedPseudoElements || neighbour.getAttachedPseudoElementsCount() !== 2) {\r\n          continue;\r\n        }\r\n\r\n        const pseudoElements = neighbour.getAttachedPseudoElements();\r\n\r\n        if (pseudoElements.hasOwnProperty('0O') && pseudoElements.hasOwnProperty('3C')) {\r\n          neighbour.isDrawn = false;\r\n          vertex.value.attachPseudoElement('Ac', '', 0);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","/** \r\n * A static class containing helper functions for math-related tasks. \r\n */\r\nexport default class MathHelper {\r\n    /**\r\n     * Rounds a value to a given number of decimals.\r\n     *\r\n     * @static\r\n     * @param {Number} value A number.\r\n     * @param {Number} decimals The number of decimals.\r\n     * @returns {Number} A number rounded to a given number of decimals.\r\n     */\r\n    static round(value, decimals) {\r\n        decimals = decimals ? decimals : 1;\r\n        return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);\r\n    }\r\n\r\n    /**\r\n     * Returns the means of the angles contained in an array. In radians.\r\n     *\r\n     * @static\r\n     * @param {Number[]} arr An array containing angles (in radians).\r\n     * @returns {Number} The mean angle in radians.\r\n     */\r\n    static meanAngle(arr) {\r\n        let sin = 0.0;\r\n        let cos = 0.0;\r\n        \r\n        for (var i = 0; i < arr.length; i++) {\r\n            sin += Math.sin(arr[i]);\r\n            cos += Math.cos(arr[i]);\r\n        }\r\n\r\n        return Math.atan2(sin / arr.length, cos / arr.length);\r\n    }\r\n\r\n    /**\r\n     * Returns the inner angle of a n-sided regular polygon.\r\n     *\r\n     * @static\r\n     * @param {Number} n Number of sides of a regular polygon.\r\n     * @returns {Number} The inner angle of a given regular polygon.\r\n     */\r\n    static innerAngle(n) {\r\n        return SmilesDrawer.MathHelper.toRad((n - 2) * 180 / n);\r\n    }\r\n\r\n    /**\r\n     * Returns the circumradius of a n-sided regular polygon with a given side-length.\r\n     *\r\n     * @static\r\n     * @param {Number} s The side length of the regular polygon.\r\n     * @param {Number} n The number of sides.\r\n     * @returns {Number} The circumradius of the regular polygon.\r\n     */\r\n    static polyCircumradius(s, n) {\r\n        return s / (2 * Math.sin(Math.PI / n));\r\n    }\r\n\r\n    /**\r\n     * Returns the apothem of a regular n-sided polygon based on its radius.\r\n     *\r\n     * @static\r\n     * @param {Number} r The radius.\r\n     * @param {Number} n The number of edges of the regular polygon.\r\n     * @returns {Number} The apothem of a n-sided polygon based on its radius.\r\n     */\r\n    static apothem(r, n) {\r\n        return r * Math.cos(Math.PI / n);\r\n    }\r\n\r\n    static apothemFromSideLength(s, n) {\r\n        let r = SmilesDrawer.MathHelper.polyCircumradius(s, n);\r\n        \r\n        return SmilesDrawer.MathHelper.apothem(r, n);\r\n    }\r\n\r\n    /**\r\n     * The central angle of a n-sided regular polygon. In radians.\r\n     *\r\n     * @static\r\n     * @param {Number} n The number of sides of the regular polygon.\r\n     * @returns {Number} The central angle of the n-sided polygon in radians.\r\n     */\r\n    static centralAngle(n) {\r\n        return SmilesDrawer.MathHelper.toRad(360 / n);\r\n    }\r\n\r\n    /**\r\n     * Convertes radians to degrees.\r\n     *\r\n     * @static\r\n     * @param {Number} rad An angle in radians.\r\n     * @returns {Number} The angle in degrees.\r\n     */\r\n    static toDeg(rad) {\r\n        return rad * SmilesDrawer.MathHelper.degFactor;\r\n    }\r\n\r\n    /**\r\n     * Converts degrees to radians.\r\n     *\r\n     * @static\r\n     * @param {Number} deg An angle in degrees.\r\n     * @returns {Number} The angle in radians.\r\n     */\r\n    static toRad(deg) {\r\n        return deg * SmilesDrawer.MathHelper.radFactor;\r\n    }\r\n\r\n    /**\r\n     * Returns the parity of the permutation (1 or -1)\r\n     * @param {Array} arr An array containing the permutation.\r\n     * @returns {Number} The parity of the permutation (1 or -1), where 1 means even and -1 means odd.\r\n     */\r\n    static parityOfPermutation(arr) {\r\n        let visited = new Uint8Array(arr.length);\r\n        let evenLengthCycleCount = 0;\r\n\r\n        let traverseCycle = function(i, cycleLength = 0) {\r\n            if (visited[i] === 1) {\r\n                return cycleLength;\r\n            }\r\n\r\n            cycleLength++;\r\n\r\n            visited[i] = 1;\r\n            return traverseCycle(arr[i], cycleLength);\r\n        }\r\n\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (visited[i] === 1) {\r\n                continue;\r\n            }\r\n\r\n            let cycleLength = traverseCycle(i);\r\n            evenLengthCycleCount += (1 - cycleLength % 2);\r\n        }\r\n\r\n        return evenLengthCycleCount % 2 ? -1 : 1;\r\n    }\r\n}\r\n\r\n/** The factor to convert degrees to radians. */\r\nSmilesDrawer.MathHelper.radFactor = Math.PI / 180;\r\n\r\n/** The factor to convert radians to degrees. */\r\nSmilesDrawer.MathHelper.degFactor = 180 / Math.PI;\r\n\r\n/** Two times PI. */\r\nSmilesDrawer.MathHelper.twoPI = 2 * Math.PI;"]}